<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Moving</title>
  
  <subtitle>Follow ur heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-16T15:41:46.280Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZQ-jhon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>koa-2</title>
    <link href="http://yoursite.com/2019/05/16/koa-2/"/>
    <id>http://yoursite.com/2019/05/16/koa-2/</id>
    <published>2019-05-16T23:38:20.000Z</published>
    <updated>2019-05-16T15:41:46.280Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><p>本文章原始创作地址：<a href="https://blog.csdn.net/qq_20264891/article/details/90274428" target="_blank" rel="noopener">https://blog.csdn.net/qq_20264891/article/details/90274428</a></p><p>如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 <a href="https://zq-jhon.github.io/about/" target="_blank" rel="noopener">https://zq-jhon.github.io/about/</a> 中添加我的微信</p><h2 id="MVC-分层"><a href="#MVC-分层" class="headerlink" title="MVC 分层"></a>MVC 分层</h2><p>代码地址： <a href="https://github.com/ZQ-jhon/koa-starter" target="_blank" rel="noopener">https://github.com/ZQ-jhon/koa-starter</a><br>MVC 是个老生常谈的概念了。<br>M = Model， V = View , C = Controller ， angularjs 就是典型的 MVC 框架。<br>在 <code>Angular</code> （指Angular 2+， 下同） 中，C 被拆分成 ViewModel ，因此称之为 MVVM 框架：<br>M = model 数据，驱动渲染的能源<br>V = View 视图层，指代用户可以看到的前端界面<br>ViewModel = 处理数据和视图之间的关系</p><p>那么，在 KOA 中， MVC 指代的又是什么呢?</p><h3 id="C，Controller-层"><a href="#C，Controller-层" class="headerlink" title="C，Controller 层"></a>C，Controller 层</h3><p>先不急着回答，把上一次的代码捋一捋，进一步优化一下。<br>由于之前所有的对于请求参数和数据的处理都放在 APP.js ，随着需求的增加，导致难以维护，先让我们给代码分层：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** app.js 中新增 `router.js`，专门用来处理路由相关的东西 </span></span><br><span class="line"><span class="comment"> *   router.js</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">          &lt;form action="/submit" method="post"&gt;</span></span><br><span class="line"><span class="string">            &lt;input name="account" type="text"&gt; 账号</span></span><br><span class="line"><span class="string">            &lt;br/&gt;</span></span><br><span class="line"><span class="string">            &lt;input name="password" type="password"&gt; 密码</span></span><br><span class="line"><span class="string">            &lt;br/&gt;</span></span><br><span class="line"><span class="string">            &lt;button&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">          &lt;/form&gt;</span></span><br><span class="line"><span class="string">        `</span>;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;);</span><br><span class="line">    app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.request.url === <span class="string">'/submit'</span>) &#123;</span><br><span class="line">            ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">            ctx.response.body = ctx.request.body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add router middleware:</span></span><br><span class="line">    app.use(router.routes())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>整个 <code>router</code> 也被编写并导出为一个函数，接受 koa 的实例 app，来进行中间件的使用。</p><p>还不够完美，router 中仍然存在大量的与路由无关的代码，我们进一步分层:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新建 index.controller.js</span></span><br><span class="line"><span class="comment">* index.controller.js 的职责就是：一旦收到命令，就渲染并返回表单页面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports =  <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.type = <span class="string">'text/html'</span>;</span><br><span class="line">  ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;form action="/submit" method="post"&gt;</span></span><br><span class="line"><span class="string">        &lt;input name="account" type="text"&gt; 账号</span></span><br><span class="line"><span class="string">        &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;input name="password" type="password"&gt; 密码</span></span><br><span class="line"><span class="string">        &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;button&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/form&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同理，新建 post.controller.js</span></span><br><span class="line"><span class="comment">* post.controller.js 的职责是：收到命令，就解析 body 中传来的数据，并渲染返回给前端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">    ctx.response.body = ctx.request.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的文件结构应该如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|--node_modules</span><br><span class="line">|--package.json</span><br><span class="line">|--app.js</span><br><span class="line">|--index.controller.js</span><br><span class="line">|--post.controller.js</span><br><span class="line">|--router.controller.js</span><br></pre></td></tr></table></figure><p></p><p><em>（如果读者嫌乱，可以增加 controllers 文件夹 和 routers 文件夹，将对应后缀的文件丢到对应的目录，并更新文件的引用路径。）</em></p><p>我们现在更新目录：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|--node_modules</span><br><span class="line">|--package.json</span><br><span class="line">|--app.js</span><br><span class="line">|--contollers</span><br><span class="line">    |--index.controller.js</span><br><span class="line">    |--post.controller.js</span><br><span class="line">|--routers</span><br><span class="line">    |--routers.controller.js</span><br></pre></td></tr></table></figure><p></p><p>VSCODE 提示更新引用，NICE。<br><img src="/2019/05/16/koa-2/vscode.png" title="vscode vscode vscode"></p><p>通过上面的代码可以看到，两个新建的 controller 文件，都是在处理自己的业务职责，即渲染并返回对应的数据，他们不关心路由是不是命中了自己，做到了职责单一。</p><p>我们现在在 CMD 中输入 <code>node app.js</code> 发现程序还是按照预期来执行，这里就不贴图了。</p><p>现在，按照 MVC 框架的思想来理解，业务处理的部分就是 C =&gt; controller ，我们已经完成了。</p><p>下面来看 View 层是啥？<br>假设我们现在有 100 个不同的路由来处理请求，并且每个路由要返回不同的页面，我们肯定不希望手写 100 个 html ，代码量太大了。<br>为了解放生产力，我们不得不使用模板引擎，例如 ejs , jade，nunjucks 等等，由于 <a href="https://mozilla.github.io/nunjucks/" target="_blank" rel="noopener">nunjucks </a>是 mozilla 开发的，就用它吧！（官方文档支持中文：<a href="https://mozilla.github.io/nunjucks/cn/api.html" target="_blank" rel="noopener">官方文档</a>）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 安装 及 使用</span><br><span class="line">// 随便在哪新建一个 js 文件</span><br><span class="line">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class="line">const result = nunjucks.renderString(`hello, $&#123;name&#125;`, &#123;name: 123&#125;);</span><br><span class="line">// fuck, 这里 双花括号跟 hexo 模板语法冲突了，意思大家明白就行</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p></p><p>// 通过 node.js 执行<br><img src="/2019/05/16/koa-2/result.png" title="result result result"></p><p><strong>如果你写过 Angular，Nunjucks 的东西简直是跟 Angular 的模板语法一毛一样</strong><br>支持管道，双花括号取值 ,逻辑判断，循环，继承，还有：<br><strong>防止 XSS 攻击，支持可配置的转义 消毒(sanitizer)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nunjucks = <span class="built_in">require</span>(<span class="string">'nunjucks'</span>);</span><br><span class="line">nunjucks.configure(<span class="string">'./'</span>, &#123;<span class="attr">autoescape</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// 默认对当前文件夹下的文件进行转义过滤，消毒处理</span></span><br></pre></td></tr></table></figure><p>脏活都被 nunjucks 干完了。</p><h3 id="使用-nunjucks"><a href="#使用-nunjucks" class="headerlink" title="使用 nunjucks"></a>使用 nunjucks</h3><p>下面，我们将 默认 路由下，返回 post 页面的代码，用 nunjucks 来进行重构</p><p>在 controller 层同级下，新建 views 目录，然后<br>新建 from.html 模板文件<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>form<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意，这里使用了 name 变量，看看待会怎么使用它！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> // fuck, 这里 双花括号跟 hexo 模板语法冲突了，意思大家明白就行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;fuck&#123;  name  &#125;fuck&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/submit"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> 账号</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span> 密码</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>接着在 renderers 下新建 renderForm.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nunjucks = <span class="built_in">require</span>(<span class="string">'nunjucks'</span>);</span><br><span class="line">nunjucks.configure(<span class="string">'views'</span>, &#123; <span class="attr">autoescape</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> htmlRenderFn = <span class="function">(<span class="params">object</span>) =&gt;</span> nunjucks.render(<span class="string">`form.html`</span>, object);</span><br><span class="line"><span class="built_in">module</span>.exports = htmlRenderFn;</span><br></pre></td></tr></table></figure><p></p><p>接着，修改原本在 index.controller.js 中渲染的函数<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> renderForm = <span class="built_in">require</span>(<span class="string">'../views/renderForm'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =  <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.type = <span class="string">'text/html'</span>;</span><br><span class="line">  ctx.body = renderForm(&#123;<span class="attr">name</span>: <span class="string">'Hello, nunjucks'</span>&#125;);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>回到第二个标题抛出的问题，我的理解是，KOA 中的 MVC ：<br>M = 泛指整个通信过程中所有的数据，包括但不限于 http 请求中传递的数据或者路由参数、query 参数、post body 体，甚至 view 层 中 nunjucks 渲染的数据来源。<br>V = view，返回给前端的视图<br>C = controller 控制器</p><p>未完待续…</p><p><b>😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;本文章原始创作地址：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/ar
      
    
    </summary>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>koa-1</title>
    <link href="http://yoursite.com/2019/05/14/koa-1/"/>
    <id>http://yoursite.com/2019/05/14/koa-1/</id>
    <published>2019-05-14T14:35:20.000Z</published>
    <updated>2019-05-16T15:39:24.070Z</updated>
    
    <content type="html"><![CDATA[<p>本文章原始创作地址：<a href="https://blog.csdn.net/qq_20264891/article/details/90216585" target="_blank" rel="noopener">https://blog.csdn.net/qq_20264891/article/details/90216585</a></p><p>如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 <a href="https://zq-jhon.github.io/about/" target="_blank" rel="noopener">https://zq-jhon.github.io/about/</a> 中添加我的微信</p><h2 id="为什么要学-Koa，不学-Express-？"><a href="#为什么要学-Koa，不学-Express-？" class="headerlink" title="为什么要学 Koa，不学 Express ？"></a>为什么要学 <code>Koa</code>，不学 <code>Express</code> ？</h2><p>因为不想写回调，日常开发习惯 <code>async await</code> 处理异步流程，因此选择 <code>Koa 2</code>。(以下简称 Koa)</p><h2 id="Koa2-核心概念"><a href="#Koa2-核心概念" class="headerlink" title="Koa2 核心概念"></a>Koa2 核心概念</h2><p>洋葱模型 其实就是 <code>async await</code> 执行流程，在 <code>koa</code> 每次调用中间件时，回调函数中 <code>next</code> 会吧执行权递交给下一个回调函数。按笔者通俗的解释为：洋葱先从外侧切到内侧，再从内测切到另一边的外侧。其实也就是回调函数被 <code>async await</code> 化了而已。<br><code>ctx(context)</code> 上下文，<code>request</code>, <code>response</code> 都被合并封装到 <code>ctx</code> 中，方便每个中间件进行操作，调用。<br><img src="/2019/05/14/koa-1/context.png" title="context context context"></p><p>打印一下 <code>ctx</code>，可见，<code>ctx</code> 描述的是，每个完整的 <code>http</code> 所包含的信息，包括但不限于 请求方法(<code>method</code>)，url(<code>request url</code>)，响应码(<code>status</code>), 响应信息 <code>message</code>, <code>header</code> 等。</p><p>路由 路由的处理也是包含在中间件中的。路由的概念并不陌生，<code>Angular</code> 中除了基本的 Router 路由器让你处理跳转路由之外，还有 <code>Activeted</code> 路由，来处理不同的 <code>Url</code> 和接受 <code>query</code> 等。 在我看来，这里 <code>Koa</code> 的路由，其实跟 <code>Angular Activeted</code> 的概念很像。代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根路由</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.request.path === <span class="string">"/"</span>) &#123;</span><br><span class="line">    ctx.response.body = <span class="string">"&lt;h1&gt;index Router&lt;/h1&gt;"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 路由</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.request.path === <span class="string">"/todo"</span>) &#123;</span><br><span class="line">    ctx.response.body = <span class="string">"&lt;h1&gt;Todo Router&lt;/h1&gt;"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完事。 Demo:<br><img src="/2019/05/14/koa-1/demo.gif"><br>但官方已经有更好的中间件了：<code>koa-router</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">"koa-router"</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根路由</span></span><br><span class="line">router.get(<span class="string">"/"</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = <span class="string">"&lt;h1&gt;index Router&lt;/h1&gt;"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 路由</span></span><br><span class="line">router.get(<span class="string">"/todo"</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = <span class="string">"&lt;h1&gt;Todo Router&lt;/h1&gt;"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br></pre></td></tr></table></figure><p>具名路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给路由起个名字，便于复用</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"user"</span>, <span class="string">"users/:id"</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = <span class="string">`你要访问的是 ： <span class="subst">$&#123;ctx.response.path&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>query param 以及 param 对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// params</span></span><br><span class="line">router.get(<span class="string">'/home/:id'</span>, <span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">ctx.response.body = ctx.params;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// query-params</span></span><br><span class="line">router.get(<span class="string">'/home'</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">ctx.response.type = <span class="string">'application/json'</span>;</span><br><span class="line">ctx.response.body = <span class="string">`<span class="subst">$&#123;ctx.request.query&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>params:-object:<br><img src="/2019/05/14/koa-1/params-object.png" title="params-object params-object params-object"><br>query-params:<br><img src="/2019/05/14/koa-1/query-params.png" title="query-params query-params query-params"><br>拿 <code>Angular</code> 中的路由做一下类比：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形如 /home/:id</span></span><br><span class="line"><span class="keyword">this</span>.activitedRoute.paramMap.subscribe(<span class="function"><span class="params">param</span> =&gt;</span> <span class="built_in">console</span>.log(param)); <span class="comment">// &#123;"id": "4"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形如 /home?a=1&amp;b=2</span></span><br><span class="line"><span class="keyword">this</span>.route.queryParamMap.subscribe(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)); <span class="comment">// map&lt;string,number&gt; = new Map(&#123;a: 1, b:2&#125;);</span></span><br></pre></td></tr></table></figure><p>都是根据浏览器的 <code>urlParamsMap</code> 来实现的。</p><h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><p>上述的所有请求， 都是基于 <code>GET</code> 请求的，那么如果客户端发来 <code>post</code> 请求，怎么解析 send 过来的数据呢？通过路由吗？做不到啊！所以还是得借助 ctx 上挂着的的对象来进行解析，因为 post 请求接受 <code>form Data</code> 也是异步的，所以要给 <code>ctx.request</code> 绑定监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">"koa-router"</span>)();</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用路由，直接给出 form 表单，诱导进一步的 post 操作</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;form action="/submit" method="post"&gt;</span></span><br><span class="line"><span class="string">      &lt;input name="account" type="text"&gt; 账号</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;input name="password" type="password"&gt; 密码</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;button&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行 post 操作时的 middleware</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.request.url === <span class="string">"/submit"</span>) &#123;</span><br><span class="line">    <span class="comment">// ctx.response.type = 'application/json';</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> parseData(ctx);</span><br><span class="line">    ctx.response.body = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收上下文，通过 事件监听 和 promise 来达到解析数据的目的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseData</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> str = <span class="string">""</span>;</span><br><span class="line">      ctx.req.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">        str += data;</span><br><span class="line">      &#125;);</span><br><span class="line">      ctx.req.addListener(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">        resolve(str);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router middleware:</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"server is running at http://localhost:3000"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Demo: <img src="/2019/05/14/koa-1/post.gif" title="post post post"></p><p>But， 不用这么麻烦，有对应的轮子了: <code>koa-bodyparser</code> 该中间件，会将 post 的数据，全部解析进 <code>ctx.request.body</code> 中<br>核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">"koa-bodyparser"</span>);</span><br><span class="line"><span class="comment">// 直接使用中间件</span></span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;form action="/submit" method="post"&gt;</span></span><br><span class="line"><span class="string">      &lt;input name="account" type="text"&gt; 账号</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;input name="password" type="password"&gt; 密码</span></span><br><span class="line"><span class="string">      &lt;br/&gt;</span></span><br><span class="line"><span class="string">      &lt;button&gt;提交&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.request.url === <span class="string">"/submit"</span>) &#123;</span><br><span class="line">    <span class="comment">// ctx.response.type = 'application/json';</span></span><br><span class="line"></span><br><span class="line">    ctx.response.body = ctx.request.body;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>来试试效果吧！<br><img src="/2019/05/14/koa-1/body-parser.gif" title="body-parser body-parser body-parser"><br>搞定了。</p><p><b>😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文章原始创作地址：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/90216585&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_20
      
    
    </summary>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>公告</title>
    <link href="http://yoursite.com/2019/04/11/Notice/"/>
    <id>http://yoursite.com/2019/04/11/Notice/</id>
    <published>2019-04-11T16:34:00.000Z</published>
    <updated>2019-05-16T15:41:46.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><p>如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 <a href="https://zq-jhon.github.io/about/" target="_blank" rel="noopener">https://zq-jhon.github.io/about/</a> 中添加我的微信</p><figure class="image-box"><img src="notice.png" alt="notice" title="notice"><p>notice</p></figure><p>今天打开 learnClound 发现，我的博客其实还是有人看的，还有人反映很多图片挂掉：</p><figure class="image-box"><img src="comment.png" alt="comment" title="comment"><p>comment</p></figure><p>之前的图片都是在 CSDN 上写完以后，直接 Copy 过来的， CSDN 不允许外链，因此挂了。</p><p>于是直接上了 hexo 的文章图片同步构建功能，直接使用文件名，就可以引用图片了，我只能说，GIHUB，等着扩容吧，哈哈，真香！</p><p><b>😘觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 &lt;a href=&quot;https://zq-jhon.g
      
    
    </summary>
    
    
      <category term="notice" scheme="http://yoursite.com/tags/notice/"/>
    
  </entry>
  
  <entry>
    <title>FreeCodeCamp JavaScript 基础算法练习</title>
    <link href="http://yoursite.com/2019/04/06/FreeCodeCamp%20JavaScript%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/04/06/FreeCodeCamp JavaScript 基础算法练习/</id>
    <published>2019-04-06T00:09:11.000Z</published>
    <updated>2019-05-16T15:41:46.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><h2 id="起由"><a href="#起由" class="headerlink" title="起由"></a>起由</h2><p>最近由于 996.icu 事件，才知道 GitHub 排行前十的 repo 中有这样一个项目。于是就刷起来了</p><h2 id="题-amp-解"><a href="#题-amp-解" class="headerlink" title="题 &amp; 解"></a>题 &amp; 解</h2><p><strong>1. 找出最长单词 在句子中找出最长的单词，并返回它的长度。函数的返回值应该是一个数字。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">findLongestWord(<span class="string">"The quick brown fox jumped over the lazy dog"</span>) 应该返回一个数字</span><br><span class="line">findLongestWord(<span class="string">"The quick brown fox jumped over the lazy dog"</span>) 应该返回 <span class="number">6.</span></span><br><span class="line">findLongestWord(<span class="string">"May the force be with you"</span>) 应该返回 <span class="number">5.</span></span><br><span class="line">findLongestWord(<span class="string">"Google do a barrel roll"</span>) 应该返回 <span class="number">6.</span></span><br><span class="line">findLongestWord(<span class="string">"What is the average airspeed velocity of an unladen swallow"</span>) 应该返回 <span class="number">8.</span></span><br><span class="line">findLongestWord(<span class="string">"What if we try a super-long word such as otorhinolaryngology"</span>) 应该返回 <span class="number">19.</span></span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongestWord</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 直接根据空格分割, 映射成 word 的长度，再使用 Math API 选出最大的</span></span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">' '</span>).map(<span class="function"><span class="params">word</span> =&gt;</span> word.length);</span><br><span class="line">  <span class="keyword">return</span>  <span class="built_in">Math</span>.max(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 句中单词首字母大写 确保字符串的每个单词首字母都大写，其余部分小写。像’the’和’of’这样的连接符同理。</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">titleCase(<span class="string">"I'm a little tea pot"</span>) 应该返回一个字符串</span><br><span class="line">titleCase(<span class="string">"I'm a little tea pot"</span>) 应该返回 <span class="string">"I'm A Little Tea Pot"</span>.</span><br><span class="line">titleCase(<span class="string">"sHoRt AnD sToUt"</span>) 应该返回 <span class="string">"Short And Stout"</span>.</span><br><span class="line">titleCase(<span class="string">"HERE IS MY HANDLE HERE IS MY SPOUT"</span>) 应该返回 <span class="string">"Here Is My Handle Here Is My Spout"</span>.</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 字符串处理的步骤和顺序至关重要</span></span><br><span class="line">  <span class="keyword">return</span>  str.toLowerCase().split(<span class="string">' '</span>).map(<span class="function"><span class="params">word</span> =&gt;</span> word.replace(word[<span class="number">0</span>], word[<span class="number">0</span>].toUpperCase())).join(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 找出多个数组中的最大数 右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。</strong><br><em>提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。</em><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">largestOfFour([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">13</span>, <span class="number">27</span>, <span class="number">18</span>, <span class="number">26</span>], [<span class="number">32</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">39</span>], [<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">857</span>, <span class="number">1</span>]]) 应该返回一个数组</span><br><span class="line">largestOfFour([[<span class="number">13</span>, <span class="number">27</span>, <span class="number">18</span>, <span class="number">26</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">32</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">39</span>], [<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">857</span>, <span class="number">1</span>]]) 应该返回 [<span class="number">27</span>,<span class="number">5</span>,<span class="number">39</span>,<span class="number">1001</span>].</span><br><span class="line">largestOfFour([[<span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">13</span>, <span class="number">35</span>, <span class="number">18</span>, <span class="number">26</span>], [<span class="number">32</span>, <span class="number">35</span>, <span class="number">97</span>, <span class="number">39</span>], [<span class="number">1000000</span>, <span class="number">1001</span>, <span class="number">857</span>, <span class="number">1</span>]]) 应该返回 [<span class="number">9</span>, <span class="number">35</span>, <span class="number">97</span>, <span class="number">1000000</span>].</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">child</span> =&gt;</span> result.push(<span class="built_in">Math</span>.max.call(...child)));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你以为对了吗？？？？<br>呵呵</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array= [<span class="number">1000000</span>,<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.call(...array);</span><br><span class="line"><span class="comment">// output is 1001</span></span><br><span class="line"></span><br><span class="line">所以，解答的结果中为： [<span class="number">9</span>, <span class="number">35</span>, <span class="number">97</span>, <span class="number">1001</span>]，与预期  [<span class="number">9</span>, <span class="number">35</span>, <span class="number">97</span>, <span class="number">1000000</span>] 不符</span><br><span class="line"></span><br><span class="line"><span class="comment">// WTF! WHY?</span></span><br><span class="line"><span class="comment">// 因为，在调用  `Math.max.call() ` 时，第一个参数传递 This 指针，实际上传入的却是一个数字，因此，该函数的运行时应该是这样的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">1001</span>) 等价于 <span class="built_in">Math</span>.max(<span class="number">1001</span>) </span><br><span class="line"><span class="comment">// 实际上，参数只进去一个，自己跟自己没啥好比的。因此，当数组只有两个参数时，实际的输出结果完全取决于第二个参数是啥。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确解法一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">child</span> =&gt;</span> result.push(<span class="built_in">Math</span>.max(...child)));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确解法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(child.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">     result.push(<span class="built_in">Math</span>.max(...child))</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">if</span>(child.length === <span class="number">1</span>) &#123;</span><br><span class="line">    result.push(child);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span>(result.length === <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 入参的时候应该不会传空数组，但还是防一手</span></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 检查字符串结尾 判断一个字符串(str)是否以指定的字符串(target)结尾。 如果是，返回true;如果不是，返回false。</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">confirmEnding(<span class="string">"Bastian"</span>, <span class="string">"n"</span>) 应该返回 <span class="literal">true</span>.</span><br><span class="line">confirmEnding(<span class="string">"Connor"</span>, <span class="string">"n"</span>) 应该返回 <span class="literal">false</span>.</span><br><span class="line">confirmEnding(<span class="string">"Walking on water and developing software from a specification are easy if both are frozen"</span>, <span class="string">"specification"</span>) 应该返回 <span class="literal">false</span>.</span><br><span class="line">confirmEnding(<span class="string">"He has to give me a new name"</span>, <span class="string">"name"</span>) 应该返回 <span class="literal">true</span>.</span><br><span class="line">confirmEnding(<span class="string">"He has to give me a new name"</span>, <span class="string">"me"</span>) 应该返回 <span class="literal">true</span>.</span><br><span class="line">confirmEnding(<span class="string">"He has to give me a new name"</span>, <span class="string">"na"</span>) 应该返回 <span class="literal">false</span>.</span><br><span class="line">confirmEnding(<span class="string">"If you want to save our world, you must hurry. We dont know how much longer we can withstand the nothing"</span>, <span class="string">"mountain"</span>) 应该返回 <span class="literal">false</span>.</span><br></pre></td></tr></table></figure><p></p><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmEnding</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(target.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str[str.length<span class="number">-1</span>] === target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 分割母字符串</span></span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">return</span> (arr[arr.length<span class="number">-1</span>].indexOf(target) &gt; <span class="number">0</span>) || arr[arr.length<span class="number">-1</span>] === target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>5. 重复输出字符串 （重要的事情说3遍）重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">repeat(<span class="string">"*"</span>, <span class="number">3</span>) 应该返回 <span class="string">"***"</span>.</span><br><span class="line">repeat(<span class="string">"abc"</span>, <span class="number">3</span>) 应该返回 <span class="string">"abcabcabc"</span>.</span><br><span class="line">repeat(<span class="string">"abc"</span>, <span class="number">4</span>) 应该返回 <span class="string">"abcabcabcabc"</span>.</span><br><span class="line">repeat(<span class="string">"abc"</span>, <span class="number">1</span>) 应该返回 <span class="string">"abc"</span>.</span><br><span class="line">repeat(<span class="string">"*"</span>, <span class="number">8</span>) 应该返回 <span class="string">"********"</span>.</span><br><span class="line">repeat(<span class="string">"abc"</span>, <span class="number">-2</span>) 应该返回 <span class="string">""</span>.</span><br></pre></td></tr></table></figure><p></p><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">str, num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请把你的代码写在这里</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">0</span> ? str.repeat(num) : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">str, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; num;i++) &#123;</span><br><span class="line">  result += str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="string">''</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>6. 截断字符串 （用瑞兹来截断对面的退路） 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。<br><em>但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。</em></strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">truncate(<span class="string">"A-tisket a-tasket A green and yellow basket"</span>, <span class="number">11</span>) 应该返回 <span class="string">"A-tisket..."</span>.</span><br><span class="line">truncate(<span class="string">"Peter Piper picked a peck of pickled peppers"</span>, <span class="number">14</span>) 应该返回 <span class="string">"Peter Piper..."</span>.</span><br><span class="line">truncate(<span class="string">"A-tisket a-tasket A green and yellow basket"</span>, <span class="string">"A-tisket a-tasket A green and yellow basket"</span>.length) 应该返回 <span class="string">"A-tisket a-tasket A green and yellow basket"</span>.</span><br><span class="line">truncate(<span class="string">"A-tisket a-tasket A green and yellow basket"</span>, <span class="string">"A-tisket a-tasket A green and yellow basket"</span>.length + <span class="number">2</span>) 应该返回 <span class="string">"A-tisket a-tasket A green and yellow basket"</span>.</span><br><span class="line">truncate(<span class="string">"A-"</span>, <span class="number">1</span>) 应该返回 <span class="string">"A..."</span>.</span><br><span class="line">truncate(<span class="string">"Absolutely Longer"</span>, <span class="number">2</span>) 应该返回 <span class="string">"Ab..."</span>.</span><br></pre></td></tr></table></figure><p></p><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str.length &gt; num) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.substr(<span class="number">0</span>,num<span class="number">-3</span>) + <span class="string">`...`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(num &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.substr(<span class="number">0</span>,num) + <span class="string">'...'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>7. 猴子吃香蕉, 分割数组 （猴子吃香蕉可是掰成好几段来吃哦） 把一个数组arr按照指定的数组大小size分割成若干个数组块<br>例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];<br>chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]];</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例 (test case): </span></span><br><span class="line">chunk([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>], <span class="number">2</span>) 应该返回 [[<span class="string">"a"</span>, <span class="string">"b"</span>], [<span class="string">"c"</span>, <span class="string">"d"</span>]].</span><br><span class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>) 应该返回 [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]].</span><br><span class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">2</span>) 应该返回 [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].</span><br><span class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>) 应该返回 [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].</span><br><span class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">3</span>) 应该返回 [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]].</span><br><span class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">4</span>) 应该返回 [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>]].</span><br></pre></td></tr></table></figure><p></p><p>解答<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">arr, size</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr.length &lt; size) &#123;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 请把你的代码写在这里</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; arr.length;i=i+size) &#123;</span><br><span class="line">   result.push(arr.slice(i,i+size))</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这道题一时半会我也没有思路，网上搜索的答案。<br>针对该类问题，大概的思路就是: <strong>通过迭代不断简化问题的复杂度，在每次迭代中处理细化后的小 case</strong><br>take a case:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 第一次迭代时: </span></span><br><span class="line">i = <span class="number">0</span>;  i + size = <span class="number">0</span> + <span class="number">2</span> = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 因此 ( slice 操作是半闭半开区间 )</span></span><br><span class="line">arr.slice(<span class="number">0</span>,<span class="number">2</span>) =&gt; [<span class="number">1</span>,<span class="number">2</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次迭代时：</span></span><br><span class="line">i = 之前循环末尾语句的计算结果</span><br><span class="line">i = <span class="number">2</span>; i + size = <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span>;</span><br><span class="line">arr.slice(<span class="number">2</span>,<span class="number">4</span>) =&gt; [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次迭代时， i = 4, 已经无法通过循环条件 i &lt; arr.length( 4 &gt; 3 )，退出循环体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时， result 的结果为 [[1,2],[3]]</span></span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><p><strong>8. 截断数组 返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case: </span></span><br><span class="line">slasher([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>) 应该返回 [<span class="number">3</span>].</span><br><span class="line">slasher([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>) 应该返回 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].</span><br><span class="line">slasher([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">9</span>) 应该返回 [].</span><br><span class="line">slasher([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>) 应该返回 [].</span><br><span class="line">slasher([<span class="string">"burgers"</span>, <span class="string">"fries"</span>, <span class="string">"shake"</span>], <span class="number">1</span>) 应该返回 [<span class="string">"fries"</span>, <span class="string">"shake"</span>].</span><br><span class="line">slasher([<span class="number">1</span>, <span class="number">2</span>, <span class="string">"chicken"</span>, <span class="number">3</span>, <span class="string">"potatoes"</span>, <span class="string">"cheese"</span>, <span class="number">4</span>], <span class="number">5</span>) 应该返回 [<span class="string">"cheese"</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure><p></p><p>解答：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slasher</span>(<span class="params">arr, howMany</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt; howMany) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  arr.splice(<span class="number">0</span>, howMany);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没啥好说的，splice 不是一个 pure function, 每次经过 splice 操作，都会改变原始数组</span></span><br><span class="line"><span class="comment">// 另外，数组的非纯方法还有:</span></span><br><span class="line"></span><br><span class="line"> - <span class="built_in">Array</span>.prototype.push()</span><br><span class="line"> - <span class="built_in">Array</span>.prototype.unshift()</span><br><span class="line"> - <span class="built_in">Array</span>.prototype.pop()</span><br><span class="line"> - <span class="built_in">Array</span>.prototype.shift()</span><br><span class="line"> - <span class="built_in">Array</span>.prototype.sort()</span><br></pre></td></tr></table></figure><p><strong>9. 比较字符串 （蛤蟆可以吃队友，也可以吃对手）如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。<br>举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。<br>[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。<br>[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case</span></span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"hey"</span>]) 应该返回 <span class="literal">false</span>.</span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"Hello"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"zyxwvutsrqponmlkjihgfedcba"</span>, <span class="string">"qrstu"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"Mary"</span>, <span class="string">"Army"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"Mary"</span>, <span class="string">"Aarmy"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"Alien"</span>, <span class="string">"line"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"floor"</span>, <span class="string">"for"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"neo"</span>]) 应该返回 <span class="literal">false</span>.</span><br></pre></td></tr></table></figure><p></p><p><strong>10. 比较字符串<br>（蛤蟆可以吃队友，也可以吃对手）<br>如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。<br>举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。<br>[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。<br>[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case</span></span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"hey"</span>]) 应该返回 <span class="literal">false</span>.</span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"Hello"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"zyxwvutsrqponmlkjihgfedcba"</span>, <span class="string">"qrstu"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"Mary"</span>, <span class="string">"Army"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"Mary"</span>, <span class="string">"Aarmy"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"Alien"</span>, <span class="string">"line"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"floor"</span>, <span class="string">"for"</span>]) 应该返回 <span class="literal">true</span>.</span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"neo"</span>]) 应该返回 <span class="literal">false</span>.</span><br></pre></td></tr></table></figure><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 啰里啰唆的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutation</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prev = arr[<span class="number">0</span>].toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> next = arr[<span class="number">1</span>].toLowerCase().split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> result =  <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;next.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!prev.includes(next[i])) &#123;</span><br><span class="line">      result = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装逼写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutation</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> accumulator = <span class="function">(<span class="params">acc, prev, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果只有一个成员，或者遍历不到下一个成员</span></span><br><span class="line">    <span class="keyword">if</span> (arr[index + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 相比较的两个成员都进行转为小写操作</span></span><br><span class="line">      prev = prev.toLowerCase();</span><br><span class="line">      <span class="keyword">const</span> next = arr[index + <span class="number">1</span>].toLowerCase();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; next.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 找不到后面字符串中的某个字符时，直接 return</span></span><br><span class="line">        <span class="keyword">if</span>(!prev.includes(next[i])) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        acc = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr.reduce(accumulator, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>11. 过滤数组假值 （真假美猴王）删除数组中的所有假值。<br>在JavaScript中，假值有false、null、0、””、undefined 和 NaN。</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case</span></span><br><span class="line">bouncer([<span class="number">7</span>, <span class="string">"ate"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="number">9</span>]) 应该返回 [<span class="number">7</span>, <span class="string">"ate"</span>, <span class="number">9</span>].</span><br><span class="line">bouncer([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]) 应该返回 [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].</span><br><span class="line">bouncer([<span class="literal">false</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">NaN</span>, <span class="literal">undefined</span>, <span class="string">""</span>]) 应该返回 [].</span><br><span class="line">bouncer([<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="number">2</span>, <span class="literal">undefined</span>]) 应该返回 [<span class="number">1</span>, <span class="number">2</span>].</span><br></pre></td></tr></table></figure><p></p><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bouncer</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请把你的代码写在这里</span></span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="params">member</span> =&gt;</span> <span class="built_in">Boolean</span>(member));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// API 背的熟练， Easy</span></span><br></pre></td></tr></table></figure><p></p><ol start="12"><li>摧毁数组 金克斯的迫击炮！实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 垃圾 撸啊撸，还金克斯，垃圾游戏，抄袭我 Dota</span></span><br><span class="line"><span class="comment">// test case</span></span><br><span class="line">destroyer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">3</span>) 应该返回 [<span class="number">1</span>, <span class="number">1</span>].</span><br><span class="line">destroyer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">3</span>) 应该返回 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>].</span><br><span class="line">destroyer([<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>) 应该返回 [<span class="number">1</span>].</span><br><span class="line">destroyer([<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">3</span>) 应该返回 [].</span><br><span class="line">destroyer([<span class="string">"tree"</span>, <span class="string">"hamburger"</span>, <span class="number">53</span>], <span class="string">"tree"</span>, <span class="number">53</span>) 应该返回 [<span class="string">"hamburger"</span>].</span><br></pre></td></tr></table></figure></li></ol><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params">arr, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请把你的代码写在这里</span></span><br><span class="line">  <span class="keyword">const</span> params = <span class="built_in">Array</span>.from(rest);</span><br><span class="line">  params.map(<span class="function"><span class="params">member</span> =&gt;</span> &#123;</span><br><span class="line">   arr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== member);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原文中， destoryer 函数只接受一个参数，想要考察 arguments, 可改造如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destoryer</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 深拷贝一下</span></span><br><span class="line"><span class="keyword">const</span> brr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(arr));</span><br><span class="line"><span class="comment">// 把默认的数组过滤掉</span></span><br><span class="line">brr.shift();</span><br><span class="line"><span class="keyword">const</span> params = <span class="built_in">Array</span>.from(brr);</span><br><span class="line">  params.map(<span class="function"><span class="params">member</span> =&gt;</span> &#123;</span><br><span class="line">   arr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== member);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>13. 数组排序并找出元素索引<br>我身在何处？<br>先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。<br>举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。<br>同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test case</span></span><br><span class="line">where([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], <span class="number">35</span>) 应该返回 <span class="number">3.</span></span><br><span class="line">where([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], <span class="number">30</span>) 应该返回 <span class="number">2.</span></span><br><span class="line">where([<span class="number">40</span>, <span class="number">60</span>], <span class="number">50</span>) 应该返回 <span class="number">1.</span></span><br><span class="line">where([<span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>], <span class="number">3</span>) 应该返回 <span class="number">0.</span></span><br><span class="line">where([<span class="number">5</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>], <span class="number">5</span>) 应该返回 <span class="number">2.</span></span><br><span class="line">where([<span class="number">2</span>, <span class="number">20</span>, <span class="number">10</span>], <span class="number">19</span>) 应该返回 <span class="number">2.</span></span><br><span class="line">where([<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>], <span class="number">15</span>) 应该返回 <span class="number">3.</span></span><br></pre></td></tr></table></figure><p>解答<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">where</span>(<span class="params">arr, num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为什么不适用默认的 sort 参数呢？可以测试一下 [1,100,1000,1001,10000,10001 ].sort() 的结果</span></span><br><span class="line">  <span class="comment">// 进行非纯排序</span></span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// let 个变量，用于缓存最终插入的下标</span></span><br><span class="line">  <span class="keyword">let</span> insetIndex = <span class="number">0</span> ;</span><br><span class="line">  <span class="comment">// 当所有成员都小于等于给定值，那么插入的位置为最后一个</span></span><br><span class="line">  <span class="keyword">if</span>(arr.every(<span class="function"><span class="params">member</span> =&gt;</span> member &lt;= num)) &#123;</span><br><span class="line">    insetIndex = arr.length;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 当所有成员都大于等于给定值，那么插入位置为第一个</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(arr.every(<span class="function"><span class="params">member</span> =&gt;</span> member &gt;= num)) &#123;</span><br><span class="line">    insetIndex = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果都不是，那么，找到比他大的那个数的下标，将此下标作为最终的插入下标</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    insetIndex = arr.findIndex(<span class="function"><span class="params">member</span> =&gt;</span> member &gt;= num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> insetIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** PS： 在 </span></span><br><span class="line"><span class="comment">else &#123;  </span></span><br><span class="line"><span class="comment">insetIndex = arr.findIndex(member =&gt; member &gt;= num); </span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">逻辑中，我本来判断的是 </span></span><br><span class="line"><span class="comment">member =&gt; member &lt;= num </span></span><br><span class="line"><span class="comment">这样是不对的，因为可能有多个数比他小，返回第一个比他小的数，位置不准确</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p><strong>14. 凯撒密码 （让上帝的归上帝，凯撒的归凯撒）下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。<br>移位密码也就是密码中的字母会按照指定的数量来做移位。 一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。<br>写一个ROT13函数，实现输入加密字符串，输出解密字符串。</strong></p><p>什么是凯撒密码？一张图说明：<br>下图搬运自：<br><a href="https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener">https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</a><br></p><figure class="image-box"><img src="https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图片搬运自https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><p>图片搬运自https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70</p></figure><br>我的理解： 简单来说，凯撒密码的规则就是，加密和揭秘双方以一个数字作为密钥，来约定每个字母的位移顺序。例如，密钥为3时，A =&gt; D, B=&gt; E … X =&gt; A (因为X的 charCodeAt +3 已经超过了 Z，不符合规则，因此需要 先减去一个 循环的周期 26，再按照密钥+3)<br>不 BB 了， show you code<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`X`</span>.charCodeAt(<span class="number">0</span>) = <span class="number">88</span>;</span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">88</span>+<span class="number">3</span>); <span class="comment">// '[' 不符合凯撒加密规则，因此需要先往回撤回一个密码表周期, 即 26 ，再按照密钥位移 +3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">88</span><span class="number">-26</span>+<span class="number">3</span>); <span class="comment">// 'A' this is right!</span></span><br></pre></td></tr></table></figure><p></p><p>解答：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rot13</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将一段话，转换为可以被处理的二维数组 eg: `hello, my wolrd!` =&gt; [`hello,`,`my` ,`world`];</span></span><br><span class="line">    <span class="keyword">const</span> stringArrays = str.split(<span class="string">' '</span>).filter(<span class="function"><span class="params">member</span> =&gt;</span> !!member);</span><br><span class="line">    <span class="comment">// 再分别处理每一个 "单词"</span></span><br><span class="line">    <span class="keyword">const</span> parseResult = stringArrays.map(<span class="function"><span class="params">word</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将每个单词转换为数组，对每个字符进行处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(word).map(<span class="function"><span class="params">charator</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// A 对应的 ASCII =&gt; 65 , N 对应的 ASCII =&gt; 78</span></span><br><span class="line">            <span class="keyword">const</span> ZCode =  <span class="string">'Z'</span>.charCodeAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">let</span> current = charator.charCodeAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 非字母的处理方法</span></span><br><span class="line">            <span class="keyword">if</span>(current &lt; <span class="number">65</span> || current &gt; ZCode) &#123;</span><br><span class="line">                <span class="keyword">return</span> charator;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> dest = (charator.charCodeAt(<span class="number">0</span>) + <span class="number">13</span>) &gt; ZCode ? (charator.charCodeAt(<span class="number">0</span>) <span class="number">-26</span> + <span class="number">13</span>): charator.charCodeAt(<span class="number">0</span>) + <span class="number">13</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(dest); </span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;).join(<span class="string">''</span>); <span class="comment">//单词中的每个字母拼接，不用空格</span></span><br><span class="line">      </span><br><span class="line">    &#125;).join(<span class="string">' '</span>); <span class="comment">//多个单词拼接，需要空格</span></span><br><span class="line">    <span class="keyword">return</span> parseResult;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 另外，这里的 </span></span><br><span class="line"> <span class="keyword">if</span>(current &lt; <span class="number">65</span> || current &gt; ZCode) &#123;</span><br><span class="line">                <span class="keyword">return</span> charator;</span><br><span class="line">            &#125;</span><br><span class="line"> 可以使用 <span class="built_in">String</span>.match(<span class="regexp">/\w/g</span>) 来命中为数组，从而过滤掉非字母的标点符号</span><br></pre></td></tr></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些算法都是最最最最最基本的算法，然而在解决这些问题中，还是出现了卡壳的地方。<br>算法还是得多练，人脑的逻辑思维，就得靠大量算法来优化和调教~<br>keep moving !</p><p><b>😘觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;起由&quot;&gt;&lt;a href=&quot;#起由&quot; class=&quot;headerlink&quot; title=&quot;起由&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Css位移属性导致像素模糊问题解决办法</title>
    <link href="http://yoursite.com/2019/02/22/Css%E4%BD%8D%E7%A7%BB%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%83%8F%E7%B4%A0%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/22/Css位移属性导致像素模糊问题解决办法/</id>
    <published>2019-02-22T10:53:11.000Z</published>
    <updated>2019-05-16T15:41:46.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><h2 id="一、抛出问题"><a href="#一、抛出问题" class="headerlink" title="一、抛出问题"></a>一、抛出问题</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.modal-container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.modal</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translat</span>(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，是做一个模态框，该模态框使用 Hack 方法来垂直竖直两个方向居中，但是在实际操作中，会发现，整个模态框的边缘，会出现模糊的现象，仿佛打了马赛克一样。</p><p>马赛克版：<br><img src="https://img-blog.csdnimg.cn/20190222103114976.png" alt="马赛克"></p><p>高清版:<br><img src="https://img-blog.csdnimg.cn/20190222103150331.png" alt="高清版"></p><p>可能上传的图片质量不高，但在我的电脑上差异非常明显</p><h2 id="二、分析原因"><a href="#二、分析原因" class="headerlink" title="二、分析原因"></a>二、分析原因</h2><p>经过查阅资料和一通分析，发现是CSS 的 transform： translate 属性在作元素位移时，极有可能发生像素点无法对其的情况，从而导致显示模糊的问题，画个灵魂示例图：<br><img src="https://img-blog.csdnimg.cn/20190222104705597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx,size_16,color_FFFFFF,t_70" alt="灵魂示意图"></p><p>如图，正常情况下，元素的边缘应该和像素点对齐，但是经过 CSS translate 后，计算的结果并非整数的像素点，导致本来一个像素能渲染的内容，没有完全归纳在其像素点内，导致出现模糊的情况。</p><p>翻译成人话： css transform:translate(-50%,-50%) 计算后的结果很可能是 transform: translate( 100.5px, 100.5px)，就因为 0.5 所以模糊</p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>方式有二</p><p>第一种： 在 transfrom 时，使用 calc 函数 加上0.5 px ，具体代码 :<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.modal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="comment">/** 这 0.5px加或者减都可以 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translat</span>(calc(-50% + 0.5 px), <span class="built_in">calc</span>(-50% + 0.5 px));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第二种，别 transform 了，直接父元素弄成 Flex 布局，两条轴都设置居中，也能达到效果。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;一、抛出问题&quot;&gt;&lt;a href=&quot;#一、抛出问题&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Electron设置-webkit-app-region 后无法响应鼠标点击事件的解决方式</title>
    <link href="http://yoursite.com/2019/02/19/Electron%E8%AE%BE%E7%BD%AE-webkit-app-region%20%E5%90%8E%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/19/Electron设置-webkit-app-region 后无法响应鼠标点击事件的解决方式/</id>
    <published>2019-02-19T17:46:11.000Z</published>
    <updated>2019-05-16T15:41:46.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><h2 id="一、抛出问题"><a href="#一、抛出问题" class="headerlink" title="一、抛出问题"></a>一、抛出问题</h2><p>在开发 Electron 应用的过程中，想要使得窗口在普通大小可以拖动，于是设置给 title-bar css 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title-bar</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">-webkit-app-region</span>: drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是设置了这个属性后，发现在 title-bar 上双击全屏和 restore size 的功能又废了，现象如图：<br><img src="https://img-blog.csdnimg.cn/20190219173642306.gif" alt="现象"></p><p>怎么办呢？</p><h2 id="二、网上现有的方案"><a href="#二、网上现有的方案" class="headerlink" title="二、网上现有的方案"></a>二、网上现有的方案</h2><p>通过搜索不难发现，有如下方案：</p><ol><li><p>拖动不要用 -webkit-app-region 了，自己监听 mouseDown 和 mouseUp 来实现吧</p></li><li><p>父元素设置 -webkit-app-region： drag, 子元素 -webkit-app-region： no-drag 即可</p></li></ol><p>但是，本项目在实际开发过程中有点特殊，即：要实现拖拽和双击放大/缩小的所著元素为同一个 DOM</p><h2 id="三、最终解决方案"><a href="#三、最终解决方案" class="headerlink" title="三、最终解决方案"></a>三、最终解决方案</h2><p>在宿主 Dom 中嵌套一个等宽，等高，但设置了-webkit-app-region： no-drag 属性的 div 即可，上代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拖拽使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">ngClass</span>]=<span class="string">"&#123;'title-bar__drag': !isMax&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"-webkit-app-region: no-drag; width: 100%;height: 100%"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，一切都正常啦！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;一、抛出问题&quot;&gt;&lt;a href=&quot;#一、抛出问题&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="electron" scheme="http://yoursite.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>rx.js将二维数据拍扁(平)</title>
    <link href="http://yoursite.com/2018/09/26/rx.js%E5%B0%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%8B%8D%E6%89%81(%E5%B9%B3)/"/>
    <id>http://yoursite.com/2018/09/26/rx.js将二维数据拍扁(平)/</id>
    <published>2018-09-26T20:00:00.000Z</published>
    <updated>2019-05-16T15:41:46.280Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/82858004" target="_blank" rel="noopener">我的CSDN博客</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 从后台返回如下格式数据 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 期望数据结构： [...&#123; index:'', name: '', age: '' &#125;]  该数据类型的长度为 9 (所有数据拆开的总长度)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> response = &#123;</span><br><span class="line">            content: [</span><br><span class="line">                [&#123; <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'aa1'</span>, <span class="attr">age</span>: <span class="number">11</span> &#125;, &#123; <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'aa2'</span>, <span class="attr">age</span>: <span class="number">11</span> &#125;, &#123; <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'aa3'</span>, <span class="attr">age</span>: <span class="number">11</span> &#125;],</span><br><span class="line">                [&#123; <span class="attr">index</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'bb1'</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;, &#123; <span class="attr">index</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'bb2'</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;, &#123; <span class="attr">index</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'bb3'</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;],</span><br><span class="line">                [&#123; <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'cc1'</span>, <span class="attr">age</span>: <span class="number">13</span> &#125;, &#123; <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'cc2'</span>, <span class="attr">age</span>: <span class="number">13</span> &#125;, &#123; <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'cc3'</span>, <span class="attr">age</span>: <span class="number">13</span> &#125;]</span><br><span class="line"> </span><br><span class="line">            ],</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 Rx.js</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">of</span>(response).pipe(</span><br><span class="line">            map(<span class="function"><span class="params">res</span> =&gt;</span> res.content),</span><br><span class="line">            mergeMap(<span class="function"><span class="params">arr</span> =&gt;</span> <span class="keyword">from</span>(arr)),</span><br><span class="line">            mergeMap(<span class="function"><span class="params">arr</span> =&gt;</span> <span class="keyword">from</span>(arr)),</span><br><span class="line">            toArray(),</span><br><span class="line">        ).subscribe(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure><p>最终结果：</p><p><img src="https://img-blog.csdn.net/20180926193747185?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>说明：无论嵌套多复杂，嵌套几层，都能用 opreator 给拍平，这就是纯函数强大的地方，指责单一，功能明确，代码量小。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_2
      
    
    </summary>
    
    
      <category term="rxjs" scheme="http://yoursite.com/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis-CI 持续集成部署 HEXO 博客项目</title>
    <link href="http://yoursite.com/2018/08/29/%E4%BD%BF%E7%94%A8%20Travis-CI%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%20HEXO%20%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/08/29/使用 Travis-CI 持续集成部署 HEXO 博客项目/</id>
    <published>2018-08-29T15:21:08.000Z</published>
    <updated>2019-05-16T15:41:46.280Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --><p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/82183614" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="持续集成的概念"><a href="#持续集成的概念" class="headerlink" title="持续集成的概念"></a>持续集成的概念</h2><p>现在前端项目都是模块化开发，需要大量的 npm install ,编译等环节，除去在开发环节中使用诸如 webpack 这样的自动化工具，在部署的时候，也可以使用 Travis 来提升部署效率。<br>持续集成，相当于将环境搭建在云端，每次只需提交代码到对应的分支，就会触发 CI 自动构建，其中构建过程中的指令都可以指定。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><strong>已经有 HEXO 搭建的博客，并且源码存放在 HEXO 项目的分支上(分支名字随便起，不是 master 就行)。</strong><br>如图：<br><img src="https://img-blog.csdn.net/20180829150457739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="部署"></p></li><li><p><strong>熟悉 HEXO 的用法及基本指令，例如</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g // 构建</span><br><span class="line">$ hexo clean // 清除已构建的资源</span><br><span class="line">$ hexo s // 起服务</span><br></pre></td></tr></table></figure><h2 id="持续集成部署"><a href="#持续集成部署" class="headerlink" title="持续集成部署"></a>持续集成部署</h2><ul><li><p>登录<a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a>，使用github账号登录。</p></li><li><p>找到自己的 HEXO 项目：<br><img src="https://img-blog.csdn.net/20180829150920443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="HEXO项目"></p></li><li>设置选项</li></ul><p>在github添加Access Token，在右上角账号的settings-&gt;Personal access tokens.点击generate new token来生成新token<br>选择仓库权限就可以。<br></p><figure class="image-box"><img src="https://img-blog.csdn.net/20180829151058290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="get token"><p>get token</p></figure><p></p><p>除了 “删库”。其他权限都给上：<br></p><figure class="image-box"><img src="https://img-blog.csdn.net/20180829151158858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="权限分配"><p>权限分配</p></figure><p></p><p><em>(生成之后一定要保存好，因为只会出现一次，丢失了就只能再重新生成了。)</em></p><ul><li>回到Travis官网，在设置中填入刚复制的token，取一个名字，这个名字需要写到下面的配置文件中<figure class="image-box"><img src="https://img-blog.csdn.net/20180829151351186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="添加 token"><p>添加 token</p></figure></li><li>在你的hexo项目的 <strong>分支中</strong> 添加配置文件.travis.yml，并且<strong>放在 HEXO 源码分支的根目录下</strong>如下：</li></ul><p><img src="https://img-blog.csdn.net/20180829153110581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=".travis.yml"><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js: stable</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - npm install -g gulp</span><br><span class="line">  - npm install</span><br><span class="line"></span><br><span class="line"> # - npm install -g gulp</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">  - hexo g</span><br><span class="line"></span><br><span class="line">after_script:</span><br><span class="line">  - cd ./public</span><br><span class="line">  - git init</span><br><span class="line">  - git config user.name &quot;ZQ-jhon&quot;</span><br><span class="line">  - git config user.email &quot;350037310@qq.com&quot;</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m &quot;Update docs with TRAVIS-CI.&quot;</span><br><span class="line">  - `git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master`</span><br><span class="line">  </span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - hexo</span><br><span class="line">env:</span><br><span class="line"> global:</span><br><span class="line">   - GH_REF: github.com/ZQ-jhon/ZQ-jhon.github.io.git</span><br></pre></td></tr></table></figure><p></p><p>你需要修改的是 user.name，user.email，以及在 GH_REF 中填写你自己的仓库中该项目的地址( 浏览器 url 自己找规律 )。<br>要使用https协议的仓库地址，使用ssh仓库地址会失败。<br>注意这一行<code>git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot;</code> 中的githubblog就是你刚在token那里取的 Token 字段，key 要对应上。</p><p>配置完成后推送到仓库中，我们就能看到网站中在部署了。</p><ul><li><p>展示：<br>我push了一个新文件，触发了自动构建，这里可以看到构建过程，其实跟我们本地跑 npm install … 那些流程是一样的：<br><img src="https://img-blog.csdn.net/20180829152604244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="构建过程"></p><figure class="image-box"><img src="https://img-blog.csdn.net/20180829151945335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="部署成功"><p>部署成功</p></figure></li><li><p>参考：<br><a href="https://www.jianshu.com/p/5691815b81b6" target="_blank" rel="noopener">https://www.jianshu.com/p/5691815b81b6</a><br>[<a href="https://blog.csdn.net/woblog/article/details/51319364]" target="_blank" rel="noopener">https://blog.csdn.net/woblog/article/details/51319364]</a>(<a href="https://blog.csdn.net/woblog/article/details" target="_blank" rel="noopener">https://blog.csdn.net/woblog/article/details</a><br><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu May 16 2019 15:42:19 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_2
      
    
    </summary>
    
    
      <category term="Travis-CI" scheme="http://yoursite.com/tags/Travis-CI/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、Token</title>
    <link href="http://yoursite.com/2018/08/26/cookie,session,token/"/>
    <id>http://yoursite.com/2018/08/26/cookie,session,token/</id>
    <published>2018-08-26T15:57:08.000Z</published>
    <updated>2019-05-14T14:30:28.622Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://mp.csdn.net/postedit/82085958" target="_blank" rel="noopener">我的CSDN博客</a></p><p>Cookie 是比较早的服务端和客户端验证身份的方法。<br>因为 http 是无状态的，因此，每次 http 请求，服务端不知道是谁在来访，因此，对于每次来访，回传字段中会设置 set-cookie 字段，浏览器会将 cookie 保存在本地，等下次 http 请求，再发送给这个域名的服务器。</p><p>Cookie 可以由服务端来设置生命周期。</p><p>Cookie 存储在客户端本地 。</p><p>Cookie 挂载在 Document 对象下，可以用 js 修改，因此有安全风险，所以后面又引入 Session 来补全不足。</p><p>一般情况， cookie 直接写入请求头。</p><p>For eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 首次访问</span></span><br><span class="line"></span><br><span class="line">client =&gt; 访问 www.example.com</span><br><span class="line"></span><br><span class="line">server =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：</span><br><span class="line"></span><br><span class="line">&#123; set-cookie: username=uuidtest123;Domail=.example.com ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次访问</span></span><br><span class="line"></span><br><span class="line">client =&gt; 判断访问的域名，检查是否存在该域名的 cookie, 有的话就带上一起请求</span><br><span class="line"></span><br><span class="line">server =&gt; 收到来访，并含有 cookie ，回传不用再加新 cookie 了。</span><br></pre></td></tr></table></figure><p>Session 一般通过 set-cookie 一起传过来，配合 cookie 保存会话信息。</p><p>Session 的出现是为了保持用户的连接状态而做出的努力。</p><p>比如有一个场景，用户登录了 a.com ，如果登陆 a.com/profile ，查看一下个人资料，难道还要用户重新登陆吗?不合适吧？</p><p>用户判断 Cookie 所在的客户端是否还“在线”，每次客户端进行请求(动作)，都会刷新 Session 的时间值。</p><p>For eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 首次访问</span></span><br><span class="line"></span><br><span class="line">client =&gt; 访问 www.example.com</span><br><span class="line"></span><br><span class="line">server =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：</span><br><span class="line"></span><br><span class="line">&#123; set-cookie: username=uuidtest123;Domail=.example.com;sessionId=xxx;sessionFresh=<span class="number">30</span>min;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次访问</span></span><br><span class="line"></span><br><span class="line">client =&gt; 访问 www.example.com ，并自动携带 session</span><br><span class="line"></span><br><span class="line">server =&gt; 收到来访，刷新 session 的新鲜值，并通过 set-cookie 回传给客户端。</span><br><span class="line"></span><br><span class="line">如果在限定的时间内（此处是<span class="number">30</span>分钟）， session 新鲜值没有被刷新，就会被销毁。</span><br></pre></td></tr></table></figure><p>其中 cookie 的作用就是为了解决HTTP协议无状态的现状所作出的努力。至于 session 机制则是又一种在客户端与服务器之间保持状态的解决方案。 </p><p>简而言之， cookie 是辨别来访者，session 是看该来访者是否保持连接</p><p>​​​​​<br>token 和 session 很像，也是为了保持状态，一般是登陆以后，后端会返回 sessinId ,其实就是 token=&gt; 用户唯一标识，通过 Cookie 来传给后台。</p><p>token 在前端传给后端时，直接写入请求体，当做普通参数缀在后面即可。</p><p>参考： <a href="https://zhuanlan.zhihu.com/p/27736893" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27736893</a></p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://mp.csdn.net/postedit/82085958&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cookie 是比较早的服务端和客户
      
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程与响应式编程之己见</title>
    <link href="http://yoursite.com/2018/07/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B7%B1%E8%A7%81/"/>
    <id>http://yoursite.com/2018/07/22/函数式编程与响应式编程之己见/</id>
    <published>2018-07-22T13:00:08.000Z</published>
    <updated>2019-05-14T14:30:28.686Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/81157232" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="1-what-is-函数式编程？"><a href="#1-what-is-函数式编程？" class="headerlink" title="1. what is 函数式编程？"></a>1. what is 函数式编程？</h2><p>函数，在编程中，通常体现为： 输入 =&gt; 执行 =&gt; 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点:</p><p>函数必须有入参，并且函数的产出会根据入参的不同而变化。<br>函数执行的整个流程中，不会对全局变量、外部属性等产生影响。<br>函数式编程代码量小，干净。<br>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        array[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addOne(arr); <span class="comment">// 2,3,4,5,6</span></span><br></pre></td></tr></table></figure><p>写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于：</p><p>难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。<br>内部的代码很啰嗦， for 循环很low。<br>·函数式编程改进版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.map(<span class="function"><span class="params">item</span>=&gt;</span> item+<span class="number">1</span>); <span class="comment">// 3,4,5,6,7</span></span><br></pre></td></tr></table></figure><p>这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 =&gt; 每项参数 + 1 =&gt; 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。</p><h2 id="2-响应式编程"><a href="#2-响应式编程" class="headerlink" title="2. 响应式编程"></a>2. 响应式编程</h2><p>前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template: </span></span><br><span class="line"></span><br><span class="line">i<span class="string">'am &#123;&#123; name &#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// js:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">name = '</span>jhon<span class="string">';</span></span><br></pre></td></tr></table></figure></p><p>在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 &lt;=&gt; 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。</p><p>再举个例子：</p><p>c的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = a + b; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>不难看出，响应式编程特点：</p><p> 同步发生，结果会随着修改参数而实时、动态地变化。<br>存在固定的映射关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/81157232&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>NodeBB搭建过程（windows+Redis）+ 科学上网方法</title>
    <link href="http://yoursite.com/2018/06/22/NodeBB%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%88windows+Redis%EF%BC%89+%20%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/22/NodeBB搭建过程（windows+Redis）+ 科学上网方法/</id>
    <published>2018-06-22T02:04:36.000Z</published>
    <updated>2019-05-14T14:30:28.660Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/80769624" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="1-首先去-github-把项目-clone-下来："><a href="#1-首先去-github-把项目-clone-下来：" class="headerlink" title="1.首先去 github 把项目 clone 下来："></a>1.首先去 github 把项目 clone 下来：</h2><p><a href="https://github.com/NodeBB/NodeBB" target="_blank" rel="noopener">https://github.com/NodeBB/NodeBB</a></p><p>然后cd到nodebb，安装依赖 cnpm i</p><p>依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180622095626833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="install" title="" class="">                <p>install</p>            </figure></p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><p>附上中文文档：<a href="https://docs.nodebb-cn.org/" target="_blank" rel="noopener">https://docs.nodebb-cn.org/</a></p><p>1.Chocolatey 可以下载<strong>离线包</strong>，之后通过 Chocolatey 安装一些环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install -y imagemagick github python2 nodejs-lts git</span><br></pre></td></tr></table></figure><p>这里的 github , nodejs ，git 可以选择不安装，跳过。<br>2.数据库（database）选择 Redis<br>Redis 可以在菜鸟教程上面找到安装教程：<br><a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-install.html</a></p><p>安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180622095820272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Redis" title="" class="">                <p>Redis</p>            </figure></p><h2 id="3-Hello-World-Running"><a href="#3-Hello-World-Running" class="headerlink" title="3.Hello World Running"></a>3.Hello World Running</h2><p>首先，使用命令 ./nodebb build 构建静态资源，构建完如下：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/2018062210001911?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="helloworld" title="" class="">                <p>helloworld</p>            </figure></p><p>此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180622100114522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="installer" title="" class="">                <p>installer</p>            </figure></p><p>上面的直接填写，下面的数据库配置如下：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180622100206278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="database" title="" class="">                <p>database</p>            </figure><br>点击最下面的 install NodeBB 后，整个项目总算 Running 了：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180622100409227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="running" title="" class="">                <p>running</p>            </figure></p><h2 id="4-use-LANTERN-to-cross-wall-使用lantern-科学上网"><a href="#4-use-LANTERN-to-cross-wall-使用lantern-科学上网" class="headerlink" title="4 . use LANTERN to cross wall (使用lantern 科学上网)"></a>4 . use LANTERN to cross wall (使用lantern 科学上网)</h2><p>下载lantern安装包 =&gt; 一路next安装，并启动 =&gt; 右下角图标右键 ，连接 =&gt; OK<br>依赖环境 .net FrameWork 4.0 +<br>我都打包好了 :<br>链接：<a href="https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow" target="_blank" rel="noopener">https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow</a> 密码：yyfg</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/80769624&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈来北京后的工作节奏以及对前端的看法</title>
    <link href="http://yoursite.com/2018/05/23/%E8%B0%88%E4%B8%80%E8%B0%88%E6%9D%A5%E5%8C%97%E4%BA%AC%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%8A%82%E5%A5%8F%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/23/谈一谈来北京的工作节奏以及对前端的看法/</id>
    <published>2018-05-23T14:12:52.000Z</published>
    <updated>2019-05-14T14:30:28.698Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/80427169" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="为什么来北京"><a href="#为什么来北京" class="headerlink" title="为什么来北京"></a>为什么来北京</h2><p>这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。<br>那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。<br>下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。<br>虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。<br>想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。<br>其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。<br>两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：</p><ul><li>熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。</li><li>对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。</li><li>对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等</li><li>对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。</li><li>能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。<br>其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。<br>其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。<br>但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2>来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。<br>在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。<br>女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。<br>最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。<br>总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。<br>很久没有写东西，思路比较乱，想到哪写到哪。</li></ul><script type="text/javascript">const password = 'tycho';if(window.prompt('请输入密码')==password){alert('password success')}else{alert('password error');window.history.back(-1);}          </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/80427169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>基于bootstrap特殊分辨率页面的实现思路</title>
    <link href="http://yoursite.com/2018/04/14/%E5%9F%BA%E4%BA%8Ebootstrap%E7%89%B9%E6%AE%8A%E5%88%86%E8%BE%A8%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/04/14/基于bootstrap特殊分辨率页面的实现思路/</id>
    <published>2018-04-14T15:11:09.000Z</published>
    <updated>2019-05-14T14:30:28.697Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/79945485" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！</p><h2 id="1-Boostrap重构传统固定px的页面"><a href="#1-Boostrap重构传统固定px的页面" class="headerlink" title="1.Boostrap重构传统固定px的页面"></a>1.Boostrap重构传统固定px的页面</h2><p>在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。<br>PSD需求图：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180414231532595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure>整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下：</p><ol><li>给整个页面给一个 container类，并且限制 max-width 为1122px。</li><li>页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的…所以，每张图片的宽高，尽可能的去用js动态设定。</li><li>尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。</li><li>布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。<br>右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3  col-md-3  col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示：<figure class="image-box">                <img src="https://img-blog.csdn.net/20180414231323872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><h2 id="2-核心逻辑代码"><a href="#2-核心逻辑代码" class="headerlink" title="2.核心逻辑代码"></a>2.核心逻辑代码</h2></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//动态设置每个box-shadow 容器的高度，为imgLong的高度</span><br><span class="line">var h = $(&apos;#imgLong&apos;).first().height();</span><br><span class="line"></span><br><span class="line">$(&apos;.box&apos;).each(function()&#123;</span><br><span class="line">$(this).css(&#123;</span><br><span class="line">height:h</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">$(window).resize(function()&#123;</span><br><span class="line">var h=$(&quot;#imgLong&quot;).first().height();$(&quot;.box&quot;).each(function()&#123;$(this).css(&#123;height:h&#125;)&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//限制h4标签文本长度</span><br><span class="line">$(&apos;.imgTitle&apos;).each(function()&#123;</span><br><span class="line">//这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用  .split(&apos; &apos;).join(&apos;&apos;)</span><br><span class="line">var txt = $(this).text().split(&apos; &apos;).join(&apos;&apos;);</span><br><span class="line">if(txt.length&gt;20)&#123;</span><br><span class="line"></span><br><span class="line">//其实真正的标题就10个字，但是前面有10个空格</span><br><span class="line">                             $(this).text(txt.substring(0,19)+&apos;...&apos;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">//为所有调用的imgShort图片增加CLASS</span><br><span class="line"></span><br><span class="line">$(&apos;.imgShortParent img&apos;).each(function()&#123;</span><br><span class="line">$(this).addClass(&apos;imgShort&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。</span><br><span class="line">var h = $(&apos;.imgLong&apos;).first().height();</span><br><span class="line">var w = $(&apos;.imgLong&apos;).first().width();</span><br><span class="line"></span><br><span class="line">$(&apos;.col-box&apos;).each(function()&#123;</span><br><span class="line">   $(this).width(w).height(h);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(window).resize(function()&#123;</span><br><span class="line">//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。</span><br><span class="line">  $(&apos;.col-box&apos;).each(function()&#123;</span><br><span class="line">   $(this).width(w).height(h);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-不足与改进思路"><a href="#3-不足与改进思路" class="headerlink" title="3.不足与改进思路"></a>3.不足与改进思路</h2><p>3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。<br>解决方案：<br>可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。</p><p>3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。<br>解决方案：<br>用我上述的思路去实现</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/79945485&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="bootstrap" scheme="http://yoursite.com/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单/双向绑定、组件通讯</title>
    <link href="http://yoursite.com/2018/03/24/ng%E8%8B%B1%E9%9B%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E6%A6%82%E5%BF%B5%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8D%95%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2018/03/24/ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单双向绑定、组件通讯/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2019-05-14T14:30:28.661Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/80698441" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="为什么要学angualr-4-0-？"><a href="#为什么要学angualr-4-0-？" class="headerlink" title="为什么要学angualr(4.0+)？"></a>为什么要学angualr(4.0+)？</h2><ol><li>无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。</li><li>微软收购了github，还不赶紧学ts？</li></ol><h2 id="本文参考博客-资料："><a href="#本文参考博客-资料：" class="headerlink" title="本文参考博客/资料："></a>本文参考博客/资料：</h2><p>1.<a href="https://blog.csdn.net/u012967849/article/details/78767294/" target="_blank" rel="noopener">https://blog.csdn.net/u012967849/article/details/78767294/</a> （ng父子组件如何传值）<br>2.<a href="https://www.angular.cn/" target="_blank" rel="noopener">https://www.angular.cn/</a> （ng中文官网）<br>3.<a href="https://www.jianshu.com/p/a2b625a99c8d" target="_blank" rel="noopener">https://www.jianshu.com/p/a2b625a99c8d</a> （ng的class和interface区别）</p><h2 id="本篇笔记所用环境及NG版本一览："><a href="#本篇笔记所用环境及NG版本一览：" class="headerlink" title="本篇笔记所用环境及NG版本一览："></a>本篇笔记所用环境及NG版本一览：</h2><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614211344486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="NG版本" title="" class="">                <p>NG版本</p>            </figure><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><strong>1.组件的文件形式/结构：</strong><br>形如：<figure class="image-box">                <img src="https://img-blog.csdn.net/20180614211811858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="components" title="" class="">                <p>components</p>            </figure><br>跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。<br><strong>2.打包入口：</strong><br> app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614211620198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="moudle" title="" class="">                <p>moudle</p>            </figure><br>如图：<br>在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。<br>在@NgMoudle中，import则声明了使用的第三方库。<br>在 declarations 中注册了子组件。<br><strong>app目录不仅作为整个项目的打包入口，其本身也是一个根组件</strong>。<br><strong>3.模块划分：</strong></p><ol><li>根组件/模块 appMoudle</li><li>英雄列表 =&gt; heroes 组件</li><li><p>当前选择的英雄=&gt; hero-detail组件</p><h2 id="新的ng语法"><a href="#新的ng语法" class="headerlink" title="新的ng语法"></a>新的ng语法</h2><p>ng新语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*代表ng指令  不用ng-if,ng-for，类似于驼峰 ngFor ngIf </span><br><span class="line">()代表绑定事件   原生事件绑定直接写在括号里 (click) (keydown)</span><br><span class="line">[]单向绑定  代表绑定属性   [name] = &apos;jobs&apos; </span><br><span class="line">[()] 双向绑定&lt;input [(value=&quot;someValue&quot;)] type=&quot;text&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><p><em>官方称双向绑定写法叫盒子里的香蕉？？？？？？？</em></p><h2 id="父子组件状态传递"><a href="#父子组件状态传递" class="headerlink" title="父子组件状态传递"></a>父子组件状态传递</h2><p>Step1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。<br>Step2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。<br>Step2如图所示：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614212726956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Step2" title="" class="">                <p>Step2</p>            </figure><br>Step3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。<br>Step3如图所示：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614213345167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Step3" title="" class="">                <p>Step3</p>            </figure></p><p>在Vue中，通常是这样做的：<br>子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。<br>angular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。</p><h2 id="组件-运作-执行流程-的文字描述"><a href="#组件-运作-执行流程-的文字描述" class="headerlink" title="组件 运作/执行流程 的文字描述"></a>组件 运作/执行流程 的文字描述</h2><ul><li>列表组件渲染出Mock的数组 (列表组件 heroes 负责)</li><li>为每一个渲染出的项，绑定事件，并传参 (同上)</li><li>在列表组件heroes 的模版加入<code>&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</code>，这样父组件的值已经通过单向绑定至子组件，<strong>但接收与使用，决定权在于子组件</strong>。（同上）</li><li>hero-detail组件接收父组件传递过来的数值，并在内部<code>import {Input} from &#39;@angular/core&#39;</code>（hero-detail组件负责）</li><li>接着在export语句中，使用装饰器来声明+初始化 得到的属性<code>@Input() hero: Hero;</code>然后就可以用啦！  （hero-detail组件负责）</li></ul><h2 id="整体逻辑代码-步骤"><a href="#整体逻辑代码-步骤" class="headerlink" title="整体逻辑代码 步骤"></a>整体逻辑代码 步骤</h2><p><strong>Step 1</strong><br>创建列表组件，使用<code>*ngFor</code>来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li </span><br><span class="line">    *ngFor=&quot;let thisHero of heroes&quot; </span><br><span class="line">    (click)=&quot;onSelect(thisHero)&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>在对应的.ts文件中，这个方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//方法</span><br><span class="line"></span><br><span class="line"> /*定义参数类型为Hero类型，即从hero.ts导出的类：</span><br><span class="line">   export class Hero &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    name: string;</span><br><span class="line">  &#125;</span><br><span class="line">  并且，设定该方法没有返回值。</span><br><span class="line">  */</span><br><span class="line">onSelect(hero: Hero): void &#123;</span><br><span class="line"></span><br><span class="line">  //动态赋值</span><br><span class="line">  this.selectedHero = hero; </span><br><span class="line">  </span><br><span class="line"> //业务逻辑相关</span><br><span class="line">  this.bool = !this.bool;</span><br><span class="line">  this.isSelected =  &#123;</span><br><span class="line">   &apos;badge&apos;:!this.bool,</span><br><span class="line">&apos;selected&apos;:this.bool</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。<br><strong>Step 2</strong><br>在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</span><br></pre></td></tr></table></figure></p><p>把值绑定到子组件模版，这样，父组件的使命就结束了。<br><strong>Step 3</strong><br>子组件如何接收并使用父组件传来的值呢？<br>首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）<br><code>import {Input} from &#39;@angular/core&#39;</code><br>接着，装饰器来申请接收传进来值，声明+初始化二连：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Input() hero: Hero;</span><br></pre></td></tr></table></figure></p><p>哦，完事了。</p><p>此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/80698441&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记</title>
    <link href="http://yoursite.com/2018/03/11/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/11/typescript学习笔记/</id>
    <published>2018-03-11T10:28:38.000Z</published>
    <updated>2019-05-14T14:30:28.674Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79324863" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8…提前为将来的ES标准打下基础。<br>    学习tsc，不亏!</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g typescript</span><br></pre></td></tr></table></figure><p>完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your File_path</span><br><span class="line">$ tsc File_name.ts</span><br></pre></td></tr></table></figure><p>OK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180214112403989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="tsc" title="" class="">                <p>tsc</p>            </figure><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><p>1.基本类型检测</p><p>在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a:number = 1;  //OK</span><br><span class="line"></span><br><span class="line">let a:string = 1;  //error</span><br><span class="line"></span><br><span class="line">类型检测的语法，就是在变量屁股后面缀上 :类型</span><br></pre></td></tr></table></figure><p>2.数组的类型检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr:number[]=[1,2,3];   //ok   类型+[]</span><br><span class="line"> </span><br><span class="line">let brr:Array&lt;number&gt;=[4,5,6]; //OK  数组泛型+尖括号&lt; 类型 &gt;</span><br></pre></td></tr></table></figure><p>3.元组类型 Tupe </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let X:[number,string];</span><br><span class="line">x=[1,&apos;hello&apos;]; //OK</span><br><span class="line">x=[1,2];  //type error</span><br><span class="line">元组类型适用于已知个数和元素类型的数组。</span><br></pre></td></tr></table></figure><h2 id="字符串拼接及字符串模板"><a href="#字符串拼接及字符串模板" class="headerlink" title="字符串拼接及字符串模板"></a>字符串拼接及字符串模板</h2><p>拼接：跟ES6一样，通过<code>（`</code>）<code>来实现，【</code>】为Tab上面的按键。</p><p>for eg  :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let hi= (`</span><br><span class="line">hello,</span><br><span class="line">wrold!</span><br><span class="line">`);</span><br><span class="line"></span><br><span class="line">//输出 hello,world!</span><br></pre></td></tr></table></figure><p>字符串模板：提供一种更优雅的书写方式：<code>${ 变量名}</code></p><p>for eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let names:string = &apos;xiaoming&apos;;</span><br><span class="line"></span><br><span class="line">let age:number = 23;</span><br><span class="line"></span><br><span class="line">let sentence:string = (`</span><br><span class="line"></span><br><span class="line">hello,my name is $&#123;names&#125;,my age is $&#123;age&#125;</span><br><span class="line"></span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>编译后的js文件为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var names = &apos;xiaoming&apos;;</span><br><span class="line"></span><br><span class="line">var age = 23;</span><br><span class="line"></span><br><span class="line">var sentence = (&quot;\nhello,my name is &quot; + names + &quot;,my age is &quot; + age + &quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">document.body.innerHTML = sentence;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> flower &#123;a,b,c,d,e,f,g&#125;;  <span class="comment">//enum关键字，后跟枚举类型的命名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rouse:flower = flower.a;  <span class="comment">//定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性</span></span><br><span class="line"></span><br><span class="line">alert(rouse);  <span class="comment">// 0 表明rouse映射的对象，在flower中的index为0</span></span><br></pre></td></tr></table></figure><h2 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h2><p>有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。</p><p><img src="http://img.blog.csdn.net/20180214120224290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="any类型"></p><p>let不能重复定义，我就用var来演示。</p><p>Any类型也可以像数组的第一种定义方法一样，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array:</span><br><span class="line"></span><br><span class="line">let arr:number[]=[1,2,3];  // OK</span><br><span class="line"></span><br><span class="line">数字的组合，可不就是数组吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">字符串组、布尔值组...</span><br><span class="line"></span><br><span class="line">let brr:string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line"></span><br><span class="line">let crr:boolean[] = [true,false];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Any:</span><br><span class="line"></span><br><span class="line">let drr:any[]=[1,&apos;2&apos;,true];  //  OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">只知道是个类似于数组的数据类型，但是对元素的类型不做限制。</span><br></pre></td></tr></table></figure><h2 id="Void类型"><a href="#Void类型" class="headerlink" title="Void类型"></a>Void类型</h2><p>void类型表示空。常用在函数返回值，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//注意函数返回值类型检测的写法</span><br><span class="line">function foo():void&#123;</span><br><span class="line"></span><br><span class="line">alert(&apos;123&apos;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，void包含两种数据类型，就是null和undefind。</p><p>触类旁通，其实还有两个类型是null和undefind，如图所示：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180214121723225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="null&undefind" title="" class="">                <p>null&undefind</p>            </figure><p>如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。<br>写法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a:number =1; </span><br><span class="line"></span><br><span class="line">let b:any = &lt;number&gt;a ;  //赋值</span><br></pre></td></tr></table></figure><p>第二种写法:</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180214131500183?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="类型断言" title="" class="">                <p>类型断言</p>            </figure><h2 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h2><p>来看这样一段代码：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220191341275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="for循环实例" title="" class="">                <p>for循环实例</p>            </figure></p><p>在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220191448648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果" title="" class="">                <p>运行结果</p>            </figure><p>可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。</p><p><strong>究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果</strong></p><p>将上述代码的<code>var i</code>改为<code>let i</code>这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。<br>因此，代码结果如下图所示：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220191954426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="let执行结果" title="" class="">                <p>let执行结果</p>            </figure><p>再来看一个对比：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220193631816?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="使用var声明" title="" class="">                <p>使用var声明</p>            </figure><p>将var 改为let </p><p><img src="http://img.blog.csdn.net/20180220193713998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="使用let声明"></p><p>可见，两种声明，是一摸一样的输出，为什么呢？<br>var的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次<code>for(let i=0;i&lt;5;i++)</code>的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。<br><strong>因为这里没有异步函数</strong>，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。</p><p>总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。</p><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。<br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = 1 ;</span><br><span class="line"></span><br><span class="line">const a = 2 ; //error</span><br></pre></td></tr></table></figure><h2 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h2><p>普通结构赋值：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220195746635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="普通结构赋值" title="" class="">                <p>普通结构赋值</p>            </figure><p>函数参数结构赋值：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220200215178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="函数结构赋值" title="" class="">                <p>函数结构赋值</p>            </figure><p>注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。</p><h2 id="数组中的【…】解构语法"><a href="#数组中的【…】解构语法" class="headerlink" title="数组中的【…】解构语法"></a>数组中的【…】解构语法</h2><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220200938878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数组解构" title="" class="">                <p>数组解构</p>            </figure><p>输出：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220201035491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="输出" title="" class="">                <p>输出</p>            </figure><p>可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。</p><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><img src="http://img.blog.csdn.net/2018022020404810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="对象解构"></p><p><strong>直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。</strong></p><p><strong>下图是错误示范</strong>：</p><p><img src="http://img.blog.csdn.net/20180220204209671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="对象解构错误示范"></p><p>那么同理，如果在一个方法中返回对象，同样也可以被解构。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/2018022113342527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="函数返回的对象也可以解构赋值" title="" class="">                <p>函数返回的对象也可以解构赋值</p>            </figure></p><p>如果对象存在嵌套现象，可以使用冒号表达式：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180221133915180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="嵌套的对象，使用冒号表达式来嵌套化结构" title="" class="">                <p>嵌套的对象，使用冒号表达式来嵌套化结构</p>            </figure><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>还是使用…语法，进行数组或者对象的浅拷贝。</p><p>数组展开，形如：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220205541321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数组展开" title="" class="">                <p>数组展开</p>            </figure></p><p>对象展开，形如：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220205712494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="对象展开" title="" class="">                <p>对象展开</p>            </figure><p><strong>对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。</strong></p><h2 id="可选参数、默认参数"><a href="#可选参数、默认参数" class="headerlink" title="可选参数、默认参数"></a>可选参数、默认参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(a:string,b?:string,c=&quot;wang&quot;)&#123;</span><br><span class="line">console.log(a)</span><br><span class="line">console.log(b)</span><br><span class="line">console.log(c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a为string类型，b为可选参数(string类型)，c是有默认值的参数</span><br></pre></td></tr></table></figure><p><strong>确定的参数要现在第一个，不能把可选参数写在第一位。</strong></p><h2 id="函数断点Yield"><a href="#函数断点Yield" class="headerlink" title="函数断点Yield"></a>函数断点Yield</h2><p>在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    yield; //设置断点，下同</span><br><span class="line"></span><br><span class="line">    console.log(2);</span><br><span class="line"></span><br><span class="line">    yield;</span><br><span class="line"></span><br><span class="line">    console.log(3);</span><br><span class="line"></span><br><span class="line">    yield;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。</span><br><span class="line"> *必须重新赋值，再调用。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">let zoo =  foo(); </span><br><span class="line"></span><br><span class="line">//这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。</span><br><span class="line">zoo.next();//1</span><br><span class="line">zoo.next();//2</span><br><span class="line">zoo.next();//3</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>作用一：主要用于声明匿名函数，简化代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum = (a,b)=&gt;a+b</span><br><span class="line"></span><br><span class="line">上式等价于：</span><br><span class="line">var sum = function (a,b)&#123;</span><br><span class="line">retrun a+b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>作用二：消除this指针带来的歧义,优化执行上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getName (name) &#123; </span><br><span class="line"> this.name = name ;</span><br><span class="line">  setInterval(function () &#123; console.log(&apos;name is &apos;+this.name)&#125;,1000)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var john = new getName(&apos;jhon&apos;);</span><br><span class="line">console.log(john)       // 打印 name is (空)</span><br></pre></td></tr></table></figure><p>这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。</p><p>使用箭头函数改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getName (name) &#123; </span><br><span class="line"> this.name = name ;</span><br><span class="line">    setInterval(() =&gt; console.log(&apos;name is &apos;+this.name)),1000)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var john = new getName(&apos;jhon&apos;);</span><br><span class="line">console.log(john)       // 打印 name is jhon</span><br></pre></td></tr></table></figure><h2 id="For…of循环"><a href="#For…of循环" class="headerlink" title="For…of循环"></a>For…of循环</h2><p><strong>for…in 循环对象的下标</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.name = &apos;myArr&apos;;</span><br><span class="line"></span><br><span class="line">for (var n in arr) &#123; </span><br><span class="line">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class="line">&#125;</span><br><span class="line">//输出0=1,1=2,2=3,3=4,name=myArr</span><br></pre></td></tr></table></figure><p><strong>for of 循环对象的key</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.name = &apos;myArr&apos;;</span><br><span class="line"></span><br><span class="line">for (var n of arr) &#123; </span><br><span class="line">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class="line">&#125;</span><br><span class="line">//输出0=1,1=2,2=3,3=4,undefind</span><br><span class="line"></span><br><span class="line">//还可以循环字符串</span><br><span class="line">var arr =&apos;hello,world!&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var n of arr) &#123; </span><br><span class="line">    console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">//h,e,l,l,o,，w,o,r,l,d,!;</span><br></pre></td></tr></table></figure><p><strong>forEach  循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.name = &apos;myArr&apos;;</span><br><span class="line"></span><br><span class="line">arr.forEach(function (n,v) &#123; </span><br><span class="line">    console.log(n,v)</span><br><span class="line">&#125;)</span><br><span class="line">//输出1,2,3,4，但是没有输出我们定义的name</span><br></pre></td></tr></table></figure><p>总结：for…in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for…of有点鸡肋，但是胜在使用场景广泛。</p><h2 id="interface接口"><a href="#interface接口" class="headerlink" title="interface接口"></a>interface接口</h2><p>interface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/2018022210063595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="interface" title="" class="">                <p>interface</p>            </figure><p>当然，接口中预先定义的变量，也可以规定/限制函数中的参数：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180222103808977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="限制函数中的参数" title="" class="">                <p>限制函数中的参数</p>            </figure><h2 id="基于Class的继承"><a href="#基于Class的继承" class="headerlink" title="基于Class的继承"></a>基于Class的继承</h2><p>在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220210913277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="基于Class的继承" title="" class="">                <p>基于Class的继承</p>            </figure><p>访问权限关键字：<br><strong>public</strong> 公共成员。  子类、父类内部都可以访问到。</p><p><strong>private</strong> 私有成员。只允许在类中访问。</p><p><strong>protected</strong> 超类的私有成员。但是在子类中仍然可以访问。</p><p>构造器Construcor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//形如：</span><br><span class="line">constructor()&#123;</span><br><span class="line"> name?string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。</p><p>举例说明：</p><p><img src="http://img.blog.csdn.net/20180222105023915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="构造器内部的变量无法被全局访问"></p><p>这时候，只要在构造器的name上增加关键字<code>public</code>，即可在class中全局访问：</p><p><img src="http://img.blog.csdn.net/20180222105147415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="加上public，没有报错"></p><p><strong>类的继承</strong><br>真的比基于原型链的继承更加优雅和简便。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180222105737601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="通过extends关键字实现继承" title="" class="">                <p>通过extends关键字实现继承</p>            </figure></p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79324863&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>IONIC3 打包安卓apk详细过程（大量图文）</title>
    <link href="http://yoursite.com/2018/03/06/IONIC3%20%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A4%A7%E9%87%8F%E5%9B%BE%E6%96%87%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/06/IONIC3 打包安卓apk详细过程（大量图文）/</id>
    <published>2018-03-06T15:44:03.000Z</published>
    <updated>2019-05-14T14:30:28.657Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79319408" target="_blank" rel="noopener">我的CSDN博客</a></p><p>本文写于2018年2月12日 22:25:59。</p><p>如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。</p><p>经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。</p><h2 id="1-基本依赖环境"><a href="#1-基本依赖环境" class="headerlink" title="1.基本依赖环境"></a>1.基本依赖环境</h2><ol><li>nodejs环境 (作为一个前端相信你已经有了)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212223918473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="nodejs" title="" class="">                <p>nodejs</p>            </figure>最好提前配置好node的环境变量，便于全局访问</li><li>jdk(下面细说)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224004766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="JDK" title="" class="">                <p>JDK</p>            </figure></li><li>SDK(下面细说，其实主要难就难在SDK配置了)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224101120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDK" title="" class="">                <p>SDK</p>            </figure></li><li>gradle(下面细说)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224141473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gradle" title="" class="">                <p>gradle</p>            </figure></li></ol><h2 id="2-基本工具"><a href="#2-基本工具" class="headerlink" title="2. 基本工具"></a>2. 基本工具</h2><ol><li>gitbash(就是用来替代windows自带的丑陋的CMD)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224300075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gitbash" title="" class="">                <p>gitbash</p>            </figure><br>下载：我都打包了！<br>链接：<a href="https://pan.baidu.com/s/1mje7ZHu" target="_blank" rel="noopener">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</li><li>windows自带的CMD(<code>window</code>+<code>R</code>输入CMD，管理员身份运行)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224327731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="CMD" title="" class="">                <p>CMD</p>            </figure></li><li>VSCode(微软爸爸开发的前端IDE)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224349157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="VSCode" title="" class="">                <p>VSCode</p>            </figure><br>下载：请自行去微软爸爸官网下载。</li></ol><h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h2><p><strong>3.1 nodejs (需要配置环境变量)</strong><br>前端必会，跳过。<br><strong>3.2 jdk (无需配置环境变量)</strong><br>下载：已经上传网盘↓<br>链接：<a href="https://pan.baidu.com/s/1mje7ZHu" target="_blank" rel="noopener">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m<br>请自行根据系统安装32/64位的版本。<br>安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\Program Files\Java<br>OK，jdk安装完成，在cmd中，输入<code>$ java -version</code>验证是否安装成功。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212225402220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="jdk安装成功" title="" class="">                <p>jdk安装成功</p>            </figure><p>OK。<br><strong>3.3 sdk (需要配置环境变量)</strong><br>下载：跟上面的一样，我都打包了。<br>链接：<a href="https://pan.baidu.com/s/1mje7ZHu" target="_blank" rel="noopener">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</p><p>解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。<br>将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\Program Files\SDK<br>接着配置环境变量，我的电脑——右键属性——-高级系统设置——-环境变量。<br>在下面的系统变量(s)中，新建，键值对如下：<br>name: ANDROID_HOME<br>key: C:\Program Files\SDK<br>如图所示：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212230110171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDK环境变量" title="" class="">                <p>SDK环境变量</p>            </figure><p>然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\bin缀在最后面，前面有【;】分隔符。</p><p>然后运行CMD，输入<code>$ android -h</code>，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212230459827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ANDROID环境配置验证" title="" class="">                <p>ANDROID环境配置验证</p>            </figure><p>现在，打开SDK目录下的SDK Manager.exe<br>打开界面上的Tools,选择options，先配置国内镜像：</p><p>域名千万不要输入http或者https协议前缀，谁输谁哭。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212231404498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="配置镜像" title="" class="">                <p>配置镜像</p>            </figure><p>下面记得勾选。<br>回到主界面，点packages再点reload<br>先勾选如下图的三个Tools:<br>分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212230934859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Tools" title="" class="">                <p>Tools</p>            </figure></p><p>别急，还没完，下面还有一个：<br>[SDK platform]<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212231104690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDK platform" title="" class="">                <p>SDK platform</p>            </figure></p><p>全部选中后，点右下角 install packages 来安装，耐心等待即可。<br><strong>3.4 gradle安装(需要配置环境变量)</strong><br>打开：<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">http://services.gradle.org/distributions/</a><br>下载：gradle-4.1-bin.zip<br>同样安装在JDK,SDK的目录下，便于查找。<br>同样的配置环境变量：<br>GRADLE_HOME=C:\Program Files\SDK\gradle-4.1<br>;%GRADLE_HOME%\bin</p><p>测试命令（查看版本）：gradle -v</p><h2 id="3-基本流程"><a href="#3-基本流程" class="headerlink" title="3.基本流程"></a>3.基本流程</h2><p>1.安装ionic和cordova </p><p>打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g ionic cordova</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224442812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="安装ionic和cordova" title="" class="">                <p>安装ionic和cordova</p>            </figure><p>2.创建ionic项目</p><p>桌面右键，在此处gitbash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic start app tabs</span><br></pre></td></tr></table></figure></p><p>耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic serve</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224746544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ionic serve" title="" class="">                <p>ionic serve</p>            </figure><p>稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：</p><p><img src="http://img.blog.csdn.net/20180212224825825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="CHROME预览"></p><p>如果做到这一步没问题，说明：<br>1.nodejs与gitbash没有问题。<br>2.ionic和cordova没有问题。</p><h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4.打包"></a>4.打包</h2><p>确保SDK,JDK没问题以后，使用指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic cordova build android --release</span><br></pre></td></tr></table></figure></p><p> (如果这条命令有问题，可以去掉–release然后debug编译，编译完成Dos会显示apk目录位置)</p><p>如若你聪慧的双眼发现如下字眼：Build Success!  即可关闭本网页，说明你已经成功打包了。</p><p>OK，此时你已经有了debug的包，但是这个包没有签名，不能发布。</p><p>此时，我们应该：<br>    First：在JDK目录下的bin文件夹下（C:\Program Files\Java\jdk1.8.0_71\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。</p><p>Second：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。<br>执行完命令1，继续执行命令2即可完成签名打包。</p><p>命令1：生成签名密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>keytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000</p><p>命令2：给文件签名<br>使用刚才生成的zhangqiang.keystore   -signedjar   签名后的apk   签名之前的apk  签名包别  </p><p>jarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212234119134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="签名完成" title="" class="">                <p>签名完成</p>            </figure><p>如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！<br>后续的软件压缩打包可以百度：jarsigner打包</p><h2 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5.疑难杂症"></a>5.疑难杂症</h2><p><strong>5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to <code>undefined</code> to prevent this warning.</strong></p><p> 出现这个提示，说明配置不正确。</p><p> 解决方法：<br>  在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postcssOptions = &#123;  </span><br><span class="line"><span class="keyword">from</span>: <span class="literal">undefined</span>,  </span><br><span class="line">to: path_1.basename(sassConfig.outFile),  </span><br><span class="line">map: autoPrefixerMapOptions  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>5.2 安卓SDK组件缺失/缺少/不匹配</strong><br>报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A problem occurred configuring project &apos;:CordovaLib&apos;.</span><br><span class="line">&gt; You have not accepted the license agreements of the following SDK components:</span><br><span class="line">  [Android SDK Build-Tools 26.0.2].</span><br></pre></td></tr></table></figure><p>原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。<br>解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。</p><p><strong>5.3 缺少安卓构建/打包工具</strong><br>报错报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,</span><br><span class="line">or on your system to install the gradle wrapper. Please include gradle</span><br><span class="line">in your path, or install Android Studio</span><br><span class="line">(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure><p>原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。<br>解决办法：<br>去<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">http://services.gradle.org/distributions/</a> 下载 gradle-4.1-bin.zip<br>配置相应的环境变量：</p><p>GRADLE_HOME=E:\software\gradle-3.0<br>PATH=%PATH%;%GRADLE_HOME%\bin</p><p>测试命令（查看版本）：gradle -v</p><p>完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) </p><p>感谢收看。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79319408&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="SDK" scheme="http://yoursite.com/tags/SDK/"/>
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="APP" scheme="http://yoursite.com/tags/APP/"/>
    
      <category term="IONIC" scheme="http://yoursite.com/tags/IONIC/"/>
    
      <category term="gradle" scheme="http://yoursite.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>javascript Dom拖动 插件 putThere.js</title>
    <link href="http://yoursite.com/2018/03/05/javascript%20Dom%E6%8B%96%E5%8A%A8%20%E6%8F%92%E4%BB%B6%20putThere.js/"/>
    <id>http://yoursite.com/2018/03/05/javascript Dom拖动 插件 putThere.js/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2019-05-14T14:30:28.661Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79171972" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="开源地址："><a href="#开源地址：" class="headerlink" title="开源地址："></a>开源地址：</h2><p>跪求各位看官给我点star吧 T.T，谢谢！<br><a href="https://github.com/ZQ-jhon/putThere.js" target="_blank" rel="noopener">https://github.com/ZQ-jhon/putThere.js</a></p><h2 id="原理及构想"><a href="#原理及构想" class="headerlink" title="原理及构想"></a>原理及构想</h2><p>关于拖动，如果不用html5的原生事件，怎样实现呢？<br>不妨先设想一下整个拖动的流程：</p><ol><li>点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute</li><li>当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)</li><li>当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>想好其中的原理，代码也就不那么难写了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//window监听</span></span><br><span class="line">               <span class="built_in">window</span>.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">               </span><br><span class="line"><span class="comment">/*鼠标按下，dom元素脱离位置，变成绝对定位*/</span></span><br><span class="line">obj.style.position=<span class="string">'absolute'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> event = <span class="built_in">window</span>.event||event;</span><br><span class="line"><span class="comment">//获取鼠标距离浏览器边界的距离</span></span><br><span class="line"><span class="keyword">var</span> x = event.clientX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = event.clientY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'鼠标距离浏览器边界(0,0)的距离('</span>+x+<span class="string">','</span>+y+<span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取dom元素距离浏览器边界的x,y值*/</span></span><br><span class="line"><span class="keyword">var</span> left = obj.style.left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> top = obj.style.top;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Dom元素距离浏览器边界(0,0)的距离('</span>+left+<span class="string">','</span>+top+<span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/</span></span><br><span class="line"><span class="keyword">if</span>(left&gt;x||top&gt;y)&#123;</span><br><span class="line"></span><br><span class="line">x=-x;</span><br><span class="line"></span><br><span class="line">y=-y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.style.left = x+<span class="string">'px'</span>; </span><br><span class="line"></span><br><span class="line">obj.style.top = y+<span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我将它封装成一个函数，调用的时候，形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">putThere(div);</span><br><span class="line"></span><br><span class="line">此时，div元素可以在<span class="built_in">document</span>中任意的拖动，改变位置。</span><br></pre></td></tr></table></figure><h2 id="效果预览："><a href="#效果预览：" class="headerlink" title="效果预览："></a>效果预览：</h2><p>鼠标拖动div效果如下：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180126140231318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Demo效果预览" title="" class="">                <p>Demo效果预览</p>            </figure><br>可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。</p><h2 id="兼容程度"><a href="#兼容程度" class="headerlink" title="兼容程度"></a>兼容程度</h2><p>实测 兼容 IE9及以上</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79171972&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="plug-in" scheme="http://yoursite.com/tags/plug-in/"/>
    
  </entry>
  
  <entry>
    <title>基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下</title>
    <link href="http://yoursite.com/2018/02/01/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/02/01/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下/</id>
    <published>2018-02-01T07:15:28.000Z</published>
    <updated>2019-05-14T14:30:37.774Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="">我的CSDN博客</a></p><h2 id="6-简单说一说盒模型，W3C和IE怪异盒模型。"><a href="#6-简单说一说盒模型，W3C和IE怪异盒模型。" class="headerlink" title="6. 简单说一说盒模型，W3C和IE怪异盒模型。"></a>6. 简单说一说盒模型，W3C和IE怪异盒模型。</h2><p>W3C标准的盒模型：width ==  content_width(不包括padding+border+margin)</p><p>IE怪异盒模型： width  == content_width+padding+border</p><p>参考我之前的博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79019724" target="_blank" rel="noopener">http://blog.csdn.net/qq_20264891/article/details/79019724</a></p><h2 id="7-简要阐述XSS和CSRF攻击及防范"><a href="#7-简要阐述XSS和CSRF攻击及防范" class="headerlink" title="7.简要阐述XSS和CSRF攻击及防范"></a>7.简要阐述XSS和CSRF攻击及防范</h2><p><strong>7.1 XSS攻击与防范</strong><br>注入攻击。<br>简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。</p><p>防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。</p><p>例如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot; name=&quot;input&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure><p>显然，正常的用户，不会再输入框里面输入形如<code>&lt;script&gt;alert(123)&lt;/script&gt;</code>的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。</p><p><strong>7.2 CSRF攻击与防范</strong></p><p>CSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。</p><p>举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。<br>防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。<br>参考文章：<a href="https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/" target="_blank" rel="noopener">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/</a><br>这篇文章写的很好。</p><h2 id="8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype"><a href="#8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype" class="headerlink" title="8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)"></a>8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)</h2><p>在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个<code>_proto_</code>对象，构造函数则有一个<code>prototype</code>对象，该对象上挂载的是可以继承的方法、属性等等。</p><p>8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？</p><p>通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。</p><h2 id="9-页面性能优化有哪些方式？"><a href="#9-页面性能优化有哪些方式？" class="headerlink" title="9.页面性能优化有哪些方式？"></a>9.页面性能优化有哪些方式？</h2><p>a.文件(css,js,img)压缩、合并（雪碧图）</p><p>b.减少请求数量</p><p>c.减少页面重排/重绘</p><p>d.使用懒加载，按需加载</p><p>e.CSS3动画有限保持帧率</p><p>f.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值</p><p>g.减少代码冗余量，精简代码</p><p>h.静态资源部署到CDN节点</p><p><strong>9.1 重绘/重排是怎么回事？有什么区别？</strong></p><p>网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。</p><p>例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的<em>重排</em>。</p><p>当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是<em>重绘</em>。</p><p>重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。</p><p><em>也就是说，重排一定会引发重绘。</em></p><p>重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。</p><p><em>也就是说，重绘现象的发生，有可能是以重排作为前提。</em></p><p><strong>9.2 请举例说明重绘，什么情况下会重绘？</strong></p><p>重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。</p><p><strong>9.3  你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</strong><br>是的。</p><p>color,background等属性会引发重绘。</p><p>浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。</p><h2 id="10-浏览器如何知道一个css文件-js文件需要缓存？"><a href="#10-浏览器如何知道一个css文件-js文件需要缓存？" class="headerlink" title="10. 浏览器如何知道一个css文件,js文件需要缓存？"></a>10. 浏览器如何知道一个css文件,js文件需要缓存？</h2><p>首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。</p><p>在<a href="https://www.cnblogs.com/shixiaomiao1122/p/7591556.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiaomiao1122/p/7591556.html</a>看到一个缓存原理图，侵删，图注的很详细：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180201144623611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="缓存机制原理图" title="" class="">                <p>缓存机制原理图</p>            </figure></p><h2 id="11-HTTP状态码304-502-503"><a href="#11-HTTP状态码304-502-503" class="headerlink" title="11.HTTP状态码304,502,503"></a>11.HTTP状态码304,502,503</h2><p>304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。</p><p>502：服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：服务器停机维护。</p><p>http状态码：<br>1XX：临时响应。并继续等待客户端的请求<br>2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容<br>3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。<br>4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。<br>5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。</p><h2 id="12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？"><a href="#12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？" class="headerlink" title="12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？"></a>12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？</h2><p>任何项目只有未发现 bug 和已经发现 bug 两种情况</p><p>不存在没有 bug 的情况</p><p>即便是测试人员也不可能覆盖 100% 的可能性</p><p>但是测试表中的要求必须 100%</p><p> 覆盖如果测试通过上线后产生的 bug </p><p>如果是测试表中未覆盖的则编制测试表的人员背锅</p><p>如果是不可抗力福利彩票背锅</p><p>作者：王小明<br>链接：<a href="https://www.zhihu.com/question/65688799/answer/233725228" target="_blank" rel="noopener">https://www.zhihu.com/question/65688799/answer/233725228</a></p><p>开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。</p><p>如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-简单说一说盒模型，W3C和IE怪异盒模型。&quot;&gt;&lt;a href=&quot;#6-简单说一说盒模型，W3C和IE怪异盒模型。&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="重绘" scheme="http://yoursite.com/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="冲排" scheme="http://yoursite.com/tags/%E5%86%B2%E6%8E%92/"/>
    
      <category term="腾讯面试" scheme="http://yoursite.com/tags/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上</title>
    <link href="http://yoursite.com/2018/01/31/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8A/"/>
    <id>http://yoursite.com/2018/01/31/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上/</id>
    <published>2018-01-31T07:28:17.000Z</published>
    <updated>2019-05-14T14:30:37.780Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79212913" target="_blank" rel="noopener">我的CSDN博客</a></p><p>这篇博客同步更新于我的GitHub博客：<a href="https://zq-jhon.github.io/2018/01/30/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94%28%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE%29%20%E4%B8%8A/" target="_blank" rel="noopener">我的GitHub博客</a></p><p>面试回顾：<a href="http://blog.csdn.net/qq_20264891/article/details/79158495" target="_blank" rel="noopener">腾讯面试回顾</a></p><h2 id="1-js中ajax发送请求的步骤"><a href="#1-js中ajax发送请求的步骤" class="headerlink" title="1.js中ajax发送请求的步骤"></a>1.js中ajax发送请求的步骤</h2><pre><code>在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下:</code></pre><p><strong>①创建XMLHttpRequest对象（标准浏览器）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> IE7及以下，这个对象为：ActiveXObject：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.ActiveXObject)&#123;</span><br><span class="line">var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 初始化请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com&apos;,是否异步?true:false);</span><br></pre></td></tr></table></figure><p><strong>③发送请求/传递数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//数据</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com/index.html&apos;,true);</span><br></pre></td></tr></table></figure><p>如果是POST方法，直接写  <code>xhr.send(&#39;数据&#39;)</code> 中。</p><p><strong>④设置异步回调callback()</strong><br>先给个错误示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//xhr.readyState 本地的请求状态</span><br><span class="line">//xhr.status 服务器返回的请求状态码</span><br><span class="line">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">  do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1</p><p>这里的异步方式主要通过一个事件来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange()=function()&#123;</span><br><span class="line"></span><br><span class="line">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">  do something...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。</p><p>反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。</p><p>扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~<br>参考文章 ，我以前的博客：<a href="https://zq-jhon.github.io/2017/11/06/Ajax%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Ajax初探</a><br>上一次的面试中，xhr.open()初始化  xhr.send()发送请求  xhr.onreadystatechange=function(){}回调函数  这三点都忘记答了，一定要注意。</p><h2 id="2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？"><a href="#2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？" class="headerlink" title="2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？"></a>2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</h2><p>事件捕获、事件响应、事件冒泡。</p><p>如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131093105267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="事件捕获和冒泡" title="" class="">                <p>事件捕获和冒泡</p>            </figure><p>不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。</p><p>一句话概括这种机制：</p><p>捕获：自外而内，从根到叶，从大到小 。</p><p>冒泡：自内而外，从叶到根，从小到大。</p><p>来做个实验，有如下的html结构 和 js代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--HTML结构--&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;</span><br><span class="line">我是DIV1</span><br><span class="line">&lt;div id=&quot;div2&quot;&gt;</span><br><span class="line">我是DIV2</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;</span><br><span class="line">i am a button</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//script代码</span><br><span class="line"></span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var div2 = document.getElementById(&apos;div2&apos;);</span><br><span class="line">var btn = document.getElementById(&apos;btn&apos;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&apos;click&apos;, function() &#123;console.log(this.id)&#125;,false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">div2.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br><span class="line"></span><br><span class="line">div1.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br></pre></td></tr></table></figure><p>HTML结构如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131094357898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="HTML结构" title="" class="">                <p>HTML结构</p>            </figure><p>当点击最里面的button，会依次出现这种情况：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131094911606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="控制台输出" title="" class="">                <p>控制台输出</p>            </figure><p>可以看到，事件是在冒泡阶段被触发的。</p><p>当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131095628141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>这次是从外向内依次触发的。</p><p>总结：<br>1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。<br>2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。</p><h2 id="3-闭包是怎么回事？用在什么场景？"><a href="#3-闭包是怎么回事？用在什么场景？" class="headerlink" title="3.闭包是怎么回事？用在什么场景？"></a>3.闭包是怎么回事？用在什么场景？</h2><p>简而言之：<strong>1、闭包就是可以访问局部作用域的变量。</strong><br>并且：        <strong>2、 可以使局部变量常驻内存</strong><br>参考阮一峰老师的闭包博客： <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">阮一峰—-闭包</a></p><p><strong>Q:闭包的内部函数为什么变量不会被销毁？</strong><br>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">var a =1;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">a+=1;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">return b();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。</p><p><strong>Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）</strong></p><p>A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。<br>人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；</p><p><strong>Q3.2：如何避免内存泄漏的问题？</strong><br>A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。</p><h2 id="4-CALL和Apply是干嘛的？"><a href="#4-CALL和Apply是干嘛的？" class="headerlink" title="4.CALL和Apply是干嘛的？"></a>4.CALL和Apply是干嘛的？</h2><p>二者都是为了更改function 的this指针，举个例子</p><p>CALL(新的this对象，原先的参数1，原先的参数2…);<br>Apply(新的this对象，[原先的参数1，原先的参数2…]);</p><p>先传入新的this对象，再传入旧方法的传参。</p><h2 id="5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？"><a href="#5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？" class="headerlink" title="5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？"></a>5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</h2><p>1.jsonp跨域<br>利用<code>&lt;script&gt;</code>标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//在js预先定义好callback()函数  </span><br><span class="line"></span><br><span class="line">function fun(data)&#123;</span><br><span class="line"></span><br><span class="line">//use data to do somethings.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//动态创建script标签，并在url中说明请求地址</span><br><span class="line">var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line"></span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line"></span><br><span class="line">script.type = &apos;text/javasctipt&apos;;</span><br><span class="line"></span><br><span class="line">script.src = &apos;require.php?callback=fun&apos;;</span><br><span class="line"></span><br><span class="line">body.appendChild(script);</span><br><span class="line"></span><br><span class="line">//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。</span><br><span class="line">      //假设传回的值是 fun(&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。</span><br></pre></td></tr></table></figure><p>这样，通过script不受跨域访问的特性，实现了跨域访问。</p><p>2.CORS跨域（主流浏览器及IE10+）<br>    对于客户端，我们还是正常使用xhr对象发送ajax请求。<br>    唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;<br>    对于服务器端，需要在 response header中设置如下两个字段:<br>    Access-Control-Allow-Origin: <a href="http://www.yourhost.com" target="_blank" rel="noopener">http://www.yourhost.com</a><br>    Access-Control-Allow-Credentials:true<br>    这样，我们就可以跨域请求接口了。</p><p>3.返回的json和jsonp有什么区别？<br>返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;&quot;name&quot;:&quot;HanMeiMei&quot;&#125;)</span><br></pre></td></tr></table></figure><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79212913&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="腾讯" scheme="http://yoursite.com/tags/%E8%85%BE%E8%AE%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="浏览器兼容" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用原生js制作一个动态简历(多动症简历)及在线预览部署过程</title>
    <link href="http://yoursite.com/2018/01/29/%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86(%E5%A4%9A%E5%8A%A8%E7%97%87%E7%AE%80%E5%8E%86)%E5%8F%8A%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/29/用原生js制作一个动态简历(多动症简历)及在线预览部署过程/</id>
    <published>2018-01-29T09:18:00.000Z</published>
    <updated>2019-05-14T14:30:28.696Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79197651" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="本项目Fork地址-欢迎Star-："><a href="#本项目Fork地址-欢迎Star-：" class="headerlink" title="本项目Fork地址(欢迎Star)："></a>本项目Fork地址(欢迎Star)：</h2><p><a href="https://github.com/ZQ-jhon/resume" target="_blank" rel="noopener">https://github.com/ZQ-jhon/resume</a></p><h2 id="本项目预览地址-Preview-Address"><a href="#本项目预览地址-Preview-Address" class="headerlink" title="本项目预览地址(Preview Address)"></a>本项目预览地址(Preview Address)</h2><p>Preview :  <a href="https://zq-jhon.github.io/resume/" target="_blank" rel="noopener">多动症简历</a></p><h2 id="项目起因"><a href="#项目起因" class="headerlink" title="项目起因"></a>项目起因</h2><p>因为在网上看到一个大神做的动态简历，如连接所示：</p><p><a href="http://strml.net/" target="_blank" rel="noopener">http://strml.net/</a></p><p>炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。</p><h2 id="引用的第三方库"><a href="#引用的第三方库" class="headerlink" title="引用的第三方库"></a>引用的第三方库</h2><p>1.jQuery  实际用到的地方只有1%</p><p>2.prism   代码高亮库。用到30%</p><p>3.marked.js markdown语法转html的库，实际用到20%</p><h2 id="技术概要"><a href="#技术概要" class="headerlink" title="技术概要"></a>技术概要</h2><p>通篇中使用的技术难度并不大，主要有：</p><ul><li><p><strong>核心原理：</strong>同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。</p></li><li><p>字符串提取、拼接。</p></li><li><p>setInterval定时器控制整个代码的吞吐节奏/速率。</p></li><li><p>在setInterval中设定一些if，用来控制总字符串的吞吐位置。</p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p><strong>1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/</strong>/，要对/进行转义，如下`\/<em>这里填写你的内容</em>\/。**</p></li></ul><p><strong>2.字符串的命名一定要切实合理： 如图所示：</strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="字符串的命名" title="" class="">                <p>字符串的命名</p>            </figure><p><strong>3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">官方js库地址：[http://prismjs.com/](http://prismjs.com/)</span><br><span class="line"></span><br><span class="line">语法:prism.heihlight(渲染的字符串,渲染的代码格式)</span><br><span class="line"></span><br><span class="line">Prism.highlight(str.substring(0,n), Prism.languages.css);</span><br></pre></td></tr></table></figure><p><strong>4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。</strong></p><p>marked.js官方库地址：<a href="https://www.npmjs.com/package/marked" target="_blank" rel="noopener">https://www.npmjs.com/package/marked</a></p><p>渲染代码如下:</p><p><code>drawBoard.innerHTML =marked(str.substring(929,1885));</code></p><p><strong>5.动态创建Pre标签（id=”drawBoard”）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：</strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="动态创建drawBoard" title="" class="">                <p>动态创建drawBoard</p>            </figure><p><strong>6.已经创建的元素无法在另外的循环中获取 ：</strong><br> <strong>在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示：</strong></p><p><img src="http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="再次赋值"></p><p><strong>7.动态下拉   同样通过n的值来让元素的溢出自动下拉</strong></p><p>如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="动态下拉" title="" class="">                <p>动态下拉</p>            </figure><p><strong>8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 </strong></p><p>其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。</p><p>代码如图：</p><p><img src="http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="魔术效果实现"></p><h2 id="核心原理代码"><a href="#核心原理代码" class="headerlink" title="核心原理代码"></a>核心原理代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义</span><br><span class="line"></span><br><span class="line">var styleTag = document.getElementById(&apos;styleTag&apos;);</span><br><span class="line"></span><br><span class="line">var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);</span><br><span class="line"></span><br><span class="line">var str = &apos;\/*大家好...今天我给大家做一个在线简历...\/*&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var n = 0;</span><br><span class="line">window.setInterval(function()&#123;</span><br><span class="line">   n++;</span><br><span class="line">   styleTag.innerHTML = str.substring(0,n);</span><br><span class="line">    </span><br><span class="line">   sourceBoard.innerHTML = str.substring(0,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;,100);</span><br><span class="line"></span><br><span class="line">//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。</span><br></pre></td></tr></table></figure><h2 id="Demo部署到GitHub详细过程"><a href="#Demo部署到GitHub详细过程" class="headerlink" title=" Demo部署到GitHub详细过程"></a> Demo部署到GitHub详细过程</h2><p>本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gh-pages预览项目" title="" class="">                <p>gh-pages预览项目</p>            </figure><p>在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。</p><p>整个部署的环节大致如下：</p><ol><li><p>在本地的项目根目录下，<code>$ git init</code></p></li><li><p>加入当前所有文件到暂存区 <code>$ git add .</code>(后面有个“·”，代表全部文件)</p></li><li><p>连接远程仓库  <code>$ git remote add origin &quot;your repository address&quot;</code></p></li><li><p>提交所有文件到git版本控制系统 <code>$ git commit -m &quot;create Demo resume&quot;</code></p></li><li><p>push到你的远程仓库 <code>$ git push origin master</code></p></li><li><p>打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。</p><p>PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub</p><h2 id="反思与不足"><a href="#反思与不足" class="headerlink" title="反思与不足"></a>反思与不足</h2></li></ol><ol><li>在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。</li></ol><ol start="2"><li><p>我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。</p><p>我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：<a href="http://strml.net/" target="_blank" rel="noopener">http://strml.net/</a>的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。</p></li><li>整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。</li></ol><ol start="4"><li>整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。</li></ol><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79197651&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="动态简历" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/"/>
    
      <category term="Github部署" scheme="http://yoursite.com/tags/Github%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
